/*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2012 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   |          Dmitry Stogov <dmitry@zend.com>                             |
   +----------------------------------------------------------------------+
*/

#ifdef ZEND_WIN32
# pragma warning(once : 4101)
#endif
static user_opcode_handler_t zend_user_opcode_handlers[256] = {
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL
};

static zend_uchar zend_user_opcodes[256] = {0,
	1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
	17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
	33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
	49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
	65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
	81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,
	97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
	113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,
	129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,
	145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,
	161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
	177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,
	193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,
	209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,
	225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
	241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
};

static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op);


#undef OPLINE
#undef DCL_OPLINE
#undef USE_OPLINE
#undef LOAD_OPLINE
#undef SAVE_OPLINE
#define OPLINE opline
#define DCL_OPLINE zend_op *opline;
#define USE_OPLINE
#define LOAD_OPLINE() opline = EX(opline)
#define SAVE_OPLINE() EX(opline) = opline
#undef CHECK_EXCEPTION
#undef HANDLE_EXCEPTION
#undef HANDLE_EXCEPTION_LEAVE
#define CHECK_EXCEPTION() LOAD_OPLINE()
#define HANDLE_EXCEPTION() LOAD_OPLINE(); ZEND_VM_CONTINUE()
#define HANDLE_EXCEPTION_LEAVE() LOAD_OPLINE(); ZEND_VM_LEAVE()
#define LOAD_REGS()
#define ZEND_VM_CONTINUE() goto zend_vm_continue
#define ZEND_VM_RETURN()   EG(in_execution) = original_in_execution; return
#define ZEND_VM_ENTER()    goto zend_vm_enter
#define ZEND_VM_LEAVE()    ZEND_VM_CONTINUE()
#define ZEND_VM_DISPATCH(opcode, opline) dispatch_handler = zend_vm_get_opcode_handler(opcode, opline); goto zend_vm_dispatch;

#define ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_INTERNAL execute_data TSRMLS_CC

ZEND_API void execute_ex(zend_execute_data *execute_data TSRMLS_DC)
{
	DCL_OPLINE
	zend_bool original_in_execution;

	opcode_handler_t dispatch_handler;
	int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC);
	incdec_t incdec_op;
	int type;
	int prop_dim;


	original_in_execution = EG(in_execution);
	EG(in_execution) = 1;

	if (0) {
zend_vm_enter:
		execute_data = i_create_execute_data_from_op_array(EG(active_op_array), 1 TSRMLS_CC);
	}

	LOAD_REGS();
	LOAD_OPLINE();

	while (1) {
zend_vm_continue:
#ifdef ZEND_WIN32
		if (EG(timed_out)) {
			zend_timeout(0);
		}
#endif

		dispatch_handler = OPLINE->handler;
zend_vm_dispatch:
		switch ((int)dispatch_handler) {
zend_leave_helper_SPEC:
{
	zend_bool nested;
	zend_op_array *op_array = EX(op_array);

	EG(current_execute_data) = EX(prev_execute_data);
	EG(opline_ptr) = NULL;
	if (!EG(active_symbol_table)) {
		i_free_compiled_variables(execute_data);
	}

	if ((op_array->fn_flags & ZEND_ACC_CLOSURE) && op_array->prototype) {
		zval_ptr_dtor((zval**)&op_array->prototype);
	}

	nested = EX(nested);

	zend_vm_stack_free((char*)execute_data - (ZEND_MM_ALIGNED_SIZE(sizeof(temp_variable)) * op_array->T) TSRMLS_CC);

	if (nested) {
		execute_data = EG(current_execute_data);
	}
	if (nested) {
		USE_OPLINE

		LOAD_REGS();
		LOAD_OPLINE();
		if (UNEXPECTED(opline->opcode == ZEND_INCLUDE_OR_EVAL)) {

			EX(function_state).function = (zend_function *) EX(op_array);
			EX(function_state).arguments = NULL;

			EG(opline_ptr) = &EX(opline);
			EG(active_op_array) = EX(op_array);
			EG(return_value_ptr_ptr) = EX(original_return_value);
			destroy_op_array(op_array TSRMLS_CC);
			efree(op_array);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zend_throw_exception_internal(NULL TSRMLS_CC);
				HANDLE_EXCEPTION_LEAVE();
			}

			ZEND_VM_INC_OPCODE();
			ZEND_VM_LEAVE();
		} else {
			EG(opline_ptr) = &EX(opline);
			EG(active_op_array) = EX(op_array);
			EG(return_value_ptr_ptr) = EX(original_return_value);
			if (EG(active_symbol_table)) {
				zend_clean_and_cache_symbol_table(EG(active_symbol_table) TSRMLS_CC);
			}
			EG(active_symbol_table) = EX(symbol_table);

			EX(function_state).function = (zend_function *) EX(op_array);
			EX(function_state).arguments = NULL;

			if (EG(This)) {
				if (UNEXPECTED(EG(exception) != NULL) && EX(call)->is_ctor_call) {
					if (EX(call)->is_ctor_result_used) {
						Z_DELREF_P(EG(This));
					}
					if (Z_REFCOUNT_P(EG(This)) == 1) {
						zend_object_store_ctor_failed(EG(This) TSRMLS_CC);
					}
				}
				zval_ptr_dtor(&EG(This));
			}
			EG(This) = EX(current_this);
			EG(scope) = EX(current_scope);
			EG(called_scope) = EX(current_called_scope);

			EX(call)--;

			zend_vm_stack_clear_multiple(1 TSRMLS_CC);

			if (UNEXPECTED(EG(exception) != NULL)) {
				zend_throw_exception_internal(NULL TSRMLS_CC);
				if (RETURN_VALUE_USED(opline) && EX_T(opline->result.var).var.ptr) {
					zval_ptr_dtor(&EX_T(opline->result.var).var.ptr);
				}
				HANDLE_EXCEPTION_LEAVE();
			}

			ZEND_VM_INC_OPCODE();
			ZEND_VM_LEAVE();
		}
	}
	ZEND_VM_RETURN();
}

zend_do_fcall_common_helper_SPEC:
{
	USE_OPLINE
	zend_bool should_change_scope = 0;
	zend_function *fbc = EX(function_state).function;

	SAVE_OPLINE();
	EX(object) = EX(call)->object;
	if (UNEXPECTED((fbc->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_DEPRECATED)) != 0)) {
		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_ABSTRACT) != 0)) {
			zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", fbc->common.scope->name, fbc->common.function_name);
		}
		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_error(E_DEPRECATED, "Function %s%s%s() is deprecated",
				fbc->common.scope ? fbc->common.scope->name : "",
				fbc->common.scope ? "::" : "",
				fbc->common.function_name);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
	}
	if (fbc->common.scope &&
		!(fbc->common.fn_flags & ZEND_ACC_STATIC) &&
		!EX(object)) {

		if (fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
			/* FIXME: output identifiers properly */
			zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically", fbc->common.scope->name, fbc->common.function_name);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		} else {
			/* FIXME: output identifiers properly */
			/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
			zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically", fbc->common.scope->name, fbc->common.function_name);
		}
	}

	if (fbc->type == ZEND_USER_FUNCTION || fbc->common.scope) {
		should_change_scope = 1;
		EX(current_this) = EG(This);
		EX(current_scope) = EG(scope);
		EX(current_called_scope) = EG(called_scope);
		EG(This) = EX(object);
		EG(scope) = (fbc->type == ZEND_USER_FUNCTION || !EX(object)) ? fbc->common.scope : NULL;
		EG(called_scope) = EX(call)->called_scope;
	}

	EX(function_state).arguments = zend_vm_stack_top(TSRMLS_C);
	zend_vm_stack_push((void*)(zend_uintptr_t)opline->extended_value TSRMLS_CC);
	LOAD_OPLINE();

	if (fbc->type == ZEND_INTERNAL_FUNCTION) {
		temp_variable *ret = &EX_T(opline->result.var);

		MAKE_STD_ZVAL(ret->var.ptr);
		ZVAL_NULL(ret->var.ptr);
		ret->var.ptr_ptr = &ret->var.ptr;
		ret->var.fcall_returned_reference = (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) != 0;

		if (fbc->common.arg_info) {
			zend_uint i=0;
			zval **p = (zval**)EX(function_state).arguments;
			ulong arg_count = opline->extended_value;

			while (arg_count>0) {
				zend_verify_arg_type(fbc, ++i, *(p-arg_count), 0 TSRMLS_CC);
				arg_count--;
			}
		}

		if (!zend_execute_internal) {
			/* saves one function call if zend_execute_internal is not used */
			fbc->internal_function.handler(opline->extended_value, ret->var.ptr, (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) ? &ret->var.ptr : NULL, EX(object), RETURN_VALUE_USED(opline) TSRMLS_CC);
		} else {
			zend_execute_internal(execute_data, NULL, RETURN_VALUE_USED(opline) TSRMLS_CC);
		}

		if (!RETURN_VALUE_USED(opline)) {
			zval_ptr_dtor(&ret->var.ptr);
		}
	} else if (fbc->type == ZEND_USER_FUNCTION) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_symbol_table) = NULL;
		EG(active_op_array) = &fbc->op_array;
		EG(return_value_ptr_ptr) = NULL;
		if (RETURN_VALUE_USED(opline)) {
			temp_variable *ret = &EX_T(opline->result.var);

			ret->var.ptr = NULL;
			EG(return_value_ptr_ptr) = &ret->var.ptr;
			ret->var.ptr_ptr = &ret->var.ptr;
			ret->var.fcall_returned_reference = (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) != 0;
		}

		if (UNEXPECTED((EG(active_op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
			if (RETURN_VALUE_USED(opline)) {
				EX_T(opline->result.var).var.ptr = zend_generator_create_zval(EG(active_op_array) TSRMLS_CC);
			}
		} else if (EXPECTED(zend_execute_ex == execute_ex)) {
			if (EXPECTED(EG(exception) == NULL)) {
				ZEND_VM_ENTER();
			}
		} else {
			zend_execute(EG(active_op_array) TSRMLS_CC);
		}

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		if (EG(active_symbol_table)) {
			zend_clean_and_cache_symbol_table(EG(active_symbol_table) TSRMLS_CC);
		}
		EG(active_symbol_table) = EX(symbol_table);
	} else { /* ZEND_OVERLOADED_FUNCTION */
		MAKE_STD_ZVAL(EX_T(opline->result.var).var.ptr);
		ZVAL_NULL(EX_T(opline->result.var).var.ptr);

		/* Not sure what should be done here if it's a static method */
		if (EXPECTED(EX(object) != NULL)) {
			Z_OBJ_HT_P(EX(object))->call_method(fbc->common.function_name, opline->extended_value, EX_T(opline->result.var).var.ptr, &EX_T(opline->result.var).var.ptr, EX(object), RETURN_VALUE_USED(opline) TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot call overloaded function for non-object");
		}

		if (fbc->type == ZEND_OVERLOADED_FUNCTION_TEMPORARY) {
			efree((char*)fbc->common.function_name);
		}
		efree(fbc);

		if (!RETURN_VALUE_USED(opline)) {
			zval_ptr_dtor(&EX_T(opline->result.var).var.ptr);
		} else {
			Z_UNSET_ISREF_P(EX_T(opline->result.var).var.ptr);
			Z_SET_REFCOUNT_P(EX_T(opline->result.var).var.ptr, 1);
			EX_T(opline->result.var).var.fcall_returned_reference = 0;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		}
	}

	EX(function_state).function = (zend_function *) EX(op_array);
	EX(function_state).arguments = NULL;

	if (should_change_scope) {
		if (EG(This)) {
			if (UNEXPECTED(EG(exception) != NULL) && EX(call)->is_ctor_call) {
				if (EX(call)->is_ctor_result_used) {
					Z_DELREF_P(EG(This));
				}
				if (Z_REFCOUNT_P(EG(This)) == 1) {
					zend_object_store_ctor_failed(EG(This) TSRMLS_CC);
				}
			}
			zval_ptr_dtor(&EG(This));
		}
		EG(This) = EX(current_this);
		EG(scope) = EX(current_scope);
		EG(called_scope) = EX(current_called_scope);
	}

	EX(call)--;

	zend_vm_stack_clear_multiple(1 TSRMLS_CC);

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_throw_exception_internal(NULL TSRMLS_CC);
		if (RETURN_VALUE_USED(opline) && EX_T(opline->result.var).var.ptr) {
			zval_ptr_dtor(&EX_T(opline->result.var).var.ptr);
		}
		HANDLE_EXCEPTION();
	}

	ZEND_VM_NEXT_OPCODE();
}

case 1050: /*ZEND_JMP_SPEC_HANDLER*/
{
	USE_OPLINE

#if DEBUG_ZEND>=2
	printf("Jumping to %d\n", opline->op1.opline_num);
#endif
	ZEND_VM_SET_OPCODE(opline->op1.jmp_addr);
	ZEND_VM_CONTINUE();
}

case 1325: /*ZEND_INIT_STRING_SPEC_HANDLER*/
{
	USE_OPLINE
	zval *tmp = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	tmp->value.str.val = emalloc(1);
	tmp->value.str.val[0] = 0;
	tmp->value.str.len = 0;
	Z_SET_REFCOUNT_P(tmp, 1);
	tmp->type = IS_STRING;
	Z_UNSET_ISREF_P(tmp);
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

case 1525: /*ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER*/
{
	EX(function_state).function = EX(call)->fbc;
	goto zend_do_fcall_common_helper_SPEC;
}

case 4025: /*ZEND_GENERATOR_RETURN_SPEC_HANDLER*/ ZEND_GENERATOR_RETURN_SPEC_LABEL:
{
	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	/* Close the generator to free up resources */
	zend_generator_close(generator, 1 TSRMLS_CC);

	/* Pass execution back to handling code */
	ZEND_VM_RETURN();
}

case 1575: /*ZEND_RECV_SPEC_HANDLER*/
{
	USE_OPLINE
	zend_uint arg_num = opline->op1.num;
	zval **param = zend_vm_stack_get_arg(arg_num TSRMLS_CC);

	SAVE_OPLINE();
	if (UNEXPECTED(param == NULL)) {
		if (zend_verify_arg_type((zend_function *) EG(active_op_array), arg_num, NULL, opline->extended_value TSRMLS_CC)) {
			const char *space;
			const char *class_name;
			zend_execute_data *ptr;

			if (EG(active_op_array)->scope) {
				class_name = EG(active_op_array)->scope->name;
				space = "::";
			} else {
				class_name = space = "";
			}
			ptr = EX(prev_execute_data);

			if(ptr && ptr->op_array) {
				zend_error(E_WARNING, "Missing argument %u for %s%s%s(), called in %s on line %d and defined", opline->op1.num, class_name, space, get_active_function_name(TSRMLS_C), ptr->op_array->filename, ptr->opline->lineno);
			} else {
				zend_error(E_WARNING, "Missing argument %u for %s%s%s()", opline->op1.num, class_name, space, get_active_function_name(TSRMLS_C));
			}
		}
	} else {
		zval **var_ptr;

		zend_verify_arg_type((zend_function *) EG(active_op_array), arg_num, *param, opline->extended_value TSRMLS_CC);
		var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->result.var TSRMLS_CC);
		Z_DELREF_PP(var_ptr);
		*var_ptr = *param;
		Z_ADDREF_PP(var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1700: /*ZEND_NEW_SPEC_HANDLER*/
{
	USE_OPLINE
	zval *object_zval;
	zend_function *constructor;

	SAVE_OPLINE();
	if (UNEXPECTED((EX_T(opline->op1.var).class_entry->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) != 0)) {
		if (EX_T(opline->op1.var).class_entry->ce_flags & ZEND_ACC_INTERFACE) {
			zend_error_noreturn(E_ERROR, "Cannot instantiate interface %s", EX_T(opline->op1.var).class_entry->name);
		} else if ((EX_T(opline->op1.var).class_entry->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT) {
			zend_error_noreturn(E_ERROR, "Cannot instantiate trait %s", EX_T(opline->op1.var).class_entry->name);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot instantiate abstract class %s", EX_T(opline->op1.var).class_entry->name);
		}
	}
	ALLOC_ZVAL(object_zval);
	object_init_ex(object_zval, EX_T(opline->op1.var).class_entry);
	INIT_PZVAL(object_zval);

	constructor = Z_OBJ_HT_P(object_zval)->get_constructor(object_zval TSRMLS_CC);

	if (constructor == NULL) {
		if (RETURN_VALUE_USED(opline)) {
			AI_SET_PTR(&EX_T(opline->result.var), object_zval);
		} else {
			zval_ptr_dtor(&object_zval);
		}
		ZEND_VM_JMP(EX(op_array)->opcodes + opline->op2.opline_num);
	} else {
		call_slot *call = EX(call_slots) + opline->extended_value;

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(object_zval);
			AI_SET_PTR(&EX_T(opline->result.var), object_zval);
		}

		/* We are not handling overloaded classes right now */
		call->fbc = constructor;
		call->object = object_zval;
		call->called_scope = EX_T(opline->op1.var).class_entry;
		call->is_ctor_call = 1;
		call->is_ctor_result_used = RETURN_VALUE_USED(opline);
		EX(call) = call;

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1425: /*ZEND_BEGIN_SILENCE_SPEC_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	Z_LVAL(EX_T(opline->result.var).tmp_var) = EG(error_reporting);
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_LONG;  /* shouldn't be necessary */
	if (EX(old_error_reporting) == NULL) {
		EX(old_error_reporting) = &EX_T(opline->result.var).tmp_var;
	}

	if (EG(error_reporting)) {
		do {
			EG(error_reporting) = 0;
			if (!EG(error_reporting_ini_entry)) {
				if (UNEXPECTED(zend_hash_find(EG(ini_directives), "error_reporting", sizeof("error_reporting"), (void **) &EG(error_reporting_ini_entry)) == FAILURE)) {
					break;
				}
			}
			if (!EG(error_reporting_ini_entry)->modified) {
				if (!EG(modified_ini_directives)) {
					ALLOC_HASHTABLE(EG(modified_ini_directives));
					zend_hash_init(EG(modified_ini_directives), 8, NULL, NULL, 0);
				}
				if (EXPECTED(zend_hash_add(EG(modified_ini_directives), "error_reporting", sizeof("error_reporting"), &EG(error_reporting_ini_entry), sizeof(zend_ini_entry*), NULL) == SUCCESS)) {
					EG(error_reporting_ini_entry)->orig_value = EG(error_reporting_ini_entry)->value;
					EG(error_reporting_ini_entry)->orig_value_length = EG(error_reporting_ini_entry)->value_length;
					EG(error_reporting_ini_entry)->orig_modifiable = EG(error_reporting_ini_entry)->modifiable;
					EG(error_reporting_ini_entry)->modified = 1;
				}
			} else if (EG(error_reporting_ini_entry)->value != EG(error_reporting_ini_entry)->orig_value) {
				efree(EG(error_reporting_ini_entry)->value);
			}
			EG(error_reporting_ini_entry)->value = estrndup("0", sizeof("0")-1);
			EG(error_reporting_ini_entry)->value_length = sizeof("0")-1;
		} while (0);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3550: /*ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER*/
{
	SAVE_OPLINE();
	zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", EG(scope)->name, EX(op_array)->function_name);
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

case 2525: /*ZEND_EXT_STMT_SPEC_HANDLER*/
{
	SAVE_OPLINE();
	if (!EG(no_extensions)) {
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_statement_handler, EX(op_array) TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2550: /*ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER*/
{
	SAVE_OPLINE();
	if (!EG(no_extensions)) {
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_begin_handler, EX(op_array) TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2575: /*ZEND_EXT_FCALL_END_SPEC_HANDLER*/
{
	SAVE_OPLINE();
	if (!EG(no_extensions)) {
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_end_handler, EX(op_array) TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3475: /*ZEND_DECLARE_CLASS_SPEC_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	EX_T(opline->result.var).class_entry = do_bind_class(EX(op_array), opline, EG(class_table), 0 TSRMLS_CC);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3500: /*ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	EX_T(opline->result.var).class_entry = do_bind_inherited_class(EX(op_array), opline, EG(class_table), EX_T(opline->extended_value).class_entry, 0 TSRMLS_CC);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3625: /*ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER*/
{
	USE_OPLINE
	zend_class_entry **pce, **pce_orig;

	SAVE_OPLINE();
	if (zend_hash_quick_find(EG(class_table), Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv)+1, Z_HASH_P(opline->op2.zv), (void**)&pce) == FAILURE ||
	    (zend_hash_quick_find(EG(class_table), Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), Z_HASH_P(opline->op1.zv), (void**)&pce_orig) == SUCCESS &&
	     *pce != *pce_orig)) {
		do_bind_inherited_class(EX(op_array), opline, EG(class_table), EX_T(opline->extended_value).class_entry, 0 TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3525: /*ZEND_DECLARE_FUNCTION_SPEC_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	do_bind_function(EX(op_array), opline, EG(function_table), 0);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2625: /*ZEND_TICKS_SPEC_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (++EG(ticks_count)>=opline->extended_value) {
		EG(ticks_count)=0;
		if (zend_ticks_function) {
			zend_ticks_function(opline->extended_value);
		}
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2600: /*ZEND_EXT_NOP_SPEC_HANDLER*/
{
	ZEND_VM_NEXT_OPCODE();
}

case 0: /*ZEND_NOP_SPEC_HANDLER*/
{
	ZEND_VM_NEXT_OPCODE();
}

case 3850: /*ZEND_ADD_TRAIT_SPEC_HANDLER*/
{
	USE_OPLINE
	zend_class_entry *ce = EX_T(opline->op1.var).class_entry;
	zend_class_entry *trait;

	SAVE_OPLINE();
	if (CACHED_PTR(opline->op2.literal->cache_slot)) {
		trait = CACHED_PTR(opline->op2.literal->cache_slot);
	} else {
		trait = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv),
		                                 Z_STRLEN_P(opline->op2.zv),
		                                 opline->op2.literal + 1,
		                                 opline->extended_value TSRMLS_CC);
		if (UNEXPECTED(trait == NULL)) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
		if (!((trait->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT)) {
			zend_error_noreturn(E_ERROR, "%s cannot use %s - it is not a trait", ce->name, trait->name);
		}
		CACHE_PTR(opline->op2.literal->cache_slot, trait);
	}

	zend_do_implement_trait(ce, trait TSRMLS_CC);

 	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3875: /*ZEND_BIND_TRAITS_SPEC_HANDLER*/
{
	USE_OPLINE
	zend_class_entry *ce = EX_T(opline->op1.var).class_entry;

	SAVE_OPLINE();
	zend_do_bind_traits(ce TSRMLS_CC);
 	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3725: /*ZEND_HANDLE_EXCEPTION_SPEC_HANDLER*/
{
	zend_uint op_num = EG(opline_before_exception)-EG(active_op_array)->opcodes;
	int i;
	zend_uint catch_op_num = 0, finally_op_num = 0;
	void **stack_frame;

	/* Figure out where the next stack frame (which maybe contains pushed
	 * arguments that have to be dtor'ed) starts */
	stack_frame = zend_vm_stack_frame_base(execute_data);

	/* If the exception was thrown during a function call there might be
	 * arguments pushed to the stack that have to be dtor'ed. */
	while (zend_vm_stack_top(TSRMLS_C) != stack_frame) {
		zval *stack_zval_p = zend_vm_stack_pop(TSRMLS_C);
		zval_ptr_dtor(&stack_zval_p);
	}

	for (i=0; i<EG(active_op_array)->last_try_catch; i++) {
		if (EG(active_op_array)->try_catch_array[i].try_op > op_num) {
			/* further blocks will not be relevant... */
			break;
		}
		if (op_num < EG(active_op_array)->try_catch_array[i].catch_op) {
			catch_op_num = EX(op_array)->try_catch_array[i].catch_op;
		}
		if (op_num < EG(active_op_array)->try_catch_array[i].finally_op) {
			finally_op_num = EX(op_array)->try_catch_array[i].finally_op;
		}
	}

	if (EX(call) >= EX(call_slots)) {
		call_slot *call = EX(call);
		do {
			if (call->object) {
				if (call->is_ctor_call) {
					if (call->is_ctor_result_used) {
						Z_DELREF_P(call->object);
					}
					if (Z_REFCOUNT_P(call->object) == 1) {
						zend_object_store_ctor_failed(call->object TSRMLS_CC);
					}
				}
				zval_ptr_dtor(&call->object);
			}
			call--;
		} while (call >= EX(call_slots));
		EX(call) = NULL;
	}

	for (i=0; i<EX(op_array)->last_brk_cont; i++) {
		if (EX(op_array)->brk_cont_array[i].start < 0) {
			continue;
		} else if (EX(op_array)->brk_cont_array[i].start > op_num) {
			/* further blocks will not be relevant... */
			break;
		} else if (op_num < EX(op_array)->brk_cont_array[i].brk) {
			if (!catch_op_num ||
			    catch_op_num >= EX(op_array)->brk_cont_array[i].brk) {
				zend_op *brk_opline = &EX(op_array)->opcodes[EX(op_array)->brk_cont_array[i].brk];

				switch (brk_opline->opcode) {
					case ZEND_SWITCH_FREE:
						if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
							zval_ptr_dtor(&EX_T(brk_opline->op1.var).var.ptr);
						}
						break;
					case ZEND_FREE:
						if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
							zendi_zval_dtor(EX_T(brk_opline->op1.var).tmp_var);
						}
						break;
				}
			}
		}
	}

	/* restore previous error_reporting value */
	if (!EG(error_reporting) && EX(old_error_reporting) != NULL && Z_LVAL_P(EX(old_error_reporting)) != 0) {
		zval restored_error_reporting;

		Z_TYPE(restored_error_reporting) = IS_LONG;
		Z_LVAL(restored_error_reporting) = Z_LVAL_P(EX(old_error_reporting));
		convert_to_string(&restored_error_reporting);
		zend_alter_ini_entry_ex("error_reporting", sizeof("error_reporting"), Z_STRVAL(restored_error_reporting), Z_STRLEN(restored_error_reporting), ZEND_INI_USER, ZEND_INI_STAGE_RUNTIME, 1 TSRMLS_CC);
		zendi_zval_dtor(restored_error_reporting);
	}
	EX(old_error_reporting) = NULL;

	if (finally_op_num && (!catch_op_num || catch_op_num >= finally_op_num)) {
		zend_exception_save(TSRMLS_C);
		EX(fast_ret) = NULL;
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[finally_op_num]);
		ZEND_VM_CONTINUE();
	} else if (catch_op_num) {
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[catch_op_num]);
		ZEND_VM_CONTINUE();
	} else {
		if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
			goto ZEND_GENERATOR_RETURN_SPEC_LABEL;
		} else {
			goto zend_leave_helper_SPEC;
		}
	}
}

case 3650: /*ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	zend_verify_abstract_class(EX_T(opline->op1.var).class_entry TSRMLS_CC);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3750: /*ZEND_USER_OPCODE_SPEC_HANDLER*/
{
	USE_OPLINE
	int ret;

	SAVE_OPLINE();
	ret = zend_user_opcode_handlers[opline->opcode](ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_INTERNAL);
	LOAD_OPLINE();

	switch (ret) {
		case ZEND_USER_OPCODE_CONTINUE:
			ZEND_VM_CONTINUE();
		case ZEND_USER_OPCODE_RETURN:
			if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
				goto ZEND_GENERATOR_RETURN_SPEC_LABEL;
			} else {
				goto zend_leave_helper_SPEC;
			}
		case ZEND_USER_OPCODE_ENTER:
			ZEND_VM_ENTER();
		case ZEND_USER_OPCODE_LEAVE:
			ZEND_VM_LEAVE();
		case ZEND_USER_OPCODE_DISPATCH:
			ZEND_VM_DISPATCH(opline->opcode, opline);
		default:
			ZEND_VM_DISPATCH((zend_uchar)(ret & 0xff), opline);
	}
}

case 3975: /*ZEND_DISCARD_EXCEPTION_SPEC_HANDLER*/
{
	if (EG(prev_exception) != NULL) {
		/* discard the previously thrown exception */
		zval_ptr_dtor(&EG(prev_exception));
		EG(prev_exception) = NULL;
	}

	ZEND_VM_NEXT_OPCODE();
}

case 4050: /*ZEND_FAST_CALL_SPEC_HANDLER*/
{
	USE_OPLINE

	if (opline->extended_value &&
	    UNEXPECTED(EG(prev_exception) != NULL)) {
	    /* in case of unhandled exception jump to catch block instead of finally */
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE();
	}
	EX(fast_ret) = opline + 1;
	ZEND_VM_SET_OPCODE(opline->op1.jmp_addr);
	ZEND_VM_CONTINUE();
}

case 4075: /*ZEND_FAST_RET_SPEC_HANDLER*/
{
	if (EX(fast_ret)) {
		ZEND_VM_SET_OPCODE(EX(fast_ret));
		ZEND_VM_CONTINUE();
	} else {
		/* special case for unhandled exceptions */
		USE_OPLINE

		if (opline->extended_value == ZEND_FAST_RET_TO_FINALLY) {
			ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
			ZEND_VM_CONTINUE();
		} else if (opline->extended_value == ZEND_FAST_RET_TO_CATCH) {
			zend_exception_restore(TSRMLS_C);
			ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
			ZEND_VM_CONTINUE();
		} else if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
			zend_exception_restore(TSRMLS_C);
			goto ZEND_GENERATOR_RETURN_SPEC_LABEL;
		} else {
			zend_exception_restore(TSRMLS_C);
			goto zend_leave_helper_SPEC;
		}
	}
}

case 2725: /*ZEND_FETCH_CLASS_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_CONST == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {

		zval *class_name = opline->op2.zv;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1475: /*ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_CONST == IS_CONST) {
		function_name = (zval*)(opline->op2.literal+1);
		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(function_name), Z_STRLEN_P(function_name)+1, Z_HASH_P(function_name), (void **) &call->fbc) == FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}
		call->object = NULL;
		call->called_scope = NULL;
		call->is_ctor_call = 0;
		EX(call) = call;
		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		char *function_name_strval, *lcname;
		int function_name_strlen;


		SAVE_OPLINE();
		function_name = opline->op2.zv;

		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			function_name_strval = Z_STRVAL_P(function_name);
			function_name_strlen = Z_STRLEN_P(function_name);
			if (function_name_strval[0] == '\\') {
			    function_name_strlen -= 1;
				lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
			} else {
				lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
			}
			if (UNEXPECTED(zend_hash_find(EG(function_table), lcname, function_name_strlen+1, (void **) &call->fbc) == FAILURE)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", function_name_strval);
			}
			efree(lcname);

			call->object = NULL;
			call->called_scope = NULL;
			call->is_ctor_call = 0;
			EX(call) = call;
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				Z_ADDREF_P(call->object);
			}
			if (IS_CONST == IS_VAR && 0 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name;
			} else {

			}
			call->is_ctor_call = 0;
			EX(call) = call;
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CONST != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zend_class_entry *ce;
			zval **method = NULL;
			zval **obj = NULL;

			zend_hash_index_find(Z_ARRVAL_P(function_name), 0, (void **) &obj);
			zend_hash_index_find(Z_ARRVAL_P(function_name), 1, (void **) &method);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_PP(obj) != IS_STRING && Z_TYPE_PP(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_PP(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_PP(obj) == IS_STRING) {
				ce = zend_fetch_class_by_name(Z_STRVAL_PP(obj), Z_STRLEN_PP(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				call->called_scope = ce;
				call->object = NULL;

				if (ce->get_static_method) {
					call->fbc = ce->get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				}
			} else {
				call->object = *obj;
				ce = call->called_scope = Z_OBJCE_PP(obj);

				call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_PP(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					if (!PZVAL_IS_REF(call->object)) {
						Z_ADDREF_P(call->object); /* For $this pointer */
					} else {
						zval *this_ptr;
						ALLOC_ZVAL(this_ptr);
						INIT_PZVAL_COPY(this_ptr, call->object);
						zval_copy_ctor(this_ptr);
						call->object = this_ptr;
					}
				}
			}

			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, Z_STRVAL_PP(method));
			}
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


case 1725: /*ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zend_literal *func_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	func_name = opline->op2.literal + 1;
	if (CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (zend_hash_quick_find(EG(function_table), Z_STRVAL(func_name->constant), Z_STRLEN(func_name->constant)+1, func_name->hash_value, (void **) &call->fbc)==FAILURE) {
		func_name++;
		if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL(func_name->constant), Z_STRLEN(func_name->constant)+1, func_name->hash_value, (void **) &call->fbc)==FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}
	} else {
		CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
	}

	call->object = NULL;
	call->called_scope = NULL;
	call->is_ctor_call = 0;
	EX(call) = call;
	ZEND_VM_NEXT_OPCODE();
}

case 1600: /*ZEND_RECV_INIT_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zval *assignment_value;
	zend_uint arg_num = opline->op1.num;
	zval **param = zend_vm_stack_get_arg(arg_num TSRMLS_CC);
	zval **var_ptr;

	SAVE_OPLINE();
	if (param == NULL) {
		ALLOC_ZVAL(assignment_value);
		*assignment_value = *opline->op2.zv;
		if ((Z_TYPE_P(assignment_value) & IS_CONSTANT_TYPE_MASK) == IS_CONSTANT ||
		     Z_TYPE_P(assignment_value)==IS_CONSTANT_ARRAY) {
			Z_SET_REFCOUNT_P(assignment_value, 1);
			zval_update_constant(&assignment_value, 0 TSRMLS_CC);
		} else {
			zval_copy_ctor(assignment_value);
		}
		INIT_PZVAL(assignment_value);
	} else {
		assignment_value = *param;
		Z_ADDREF_P(assignment_value);
	}

	zend_verify_arg_type((zend_function *) EG(active_op_array), arg_num, assignment_value, opline->extended_value TSRMLS_CC);
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->result.var TSRMLS_CC);
	Z_DELREF_PP(var_ptr);
	*var_ptr = assignment_value;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1250: /*ZEND_BRK_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zend_brk_cont_element *el;

	SAVE_OPLINE();
	el = zend_brk_cont(Z_LVAL_P(opline->op2.zv), opline->op1.opline_num,
	                   EX(op_array), execute_data TSRMLS_CC);

	ZEND_VM_JMP(EX(op_array)->opcodes + el->brk);
}

case 1275: /*ZEND_CONT_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zend_brk_cont_element *el;

	SAVE_OPLINE();
	el = zend_brk_cont(Z_LVAL_P(opline->op2.zv), opline->op1.opline_num,
	                   EX(op_array), execute_data TSRMLS_CC);

	ZEND_VM_JMP(EX(op_array)->opcodes + el->cont);
}

case 2500: /*ZEND_GOTO_SPEC_CONST_HANDLER*/
{
	zend_op *brk_opline;
	USE_OPLINE
	zend_brk_cont_element *el;

	SAVE_OPLINE();
	el = zend_brk_cont(Z_LVAL_P(opline->op2.zv), opline->extended_value,
 	                   EX(op_array), execute_data TSRMLS_CC);

	brk_opline = EX(op_array)->opcodes + el->brk;

	switch (brk_opline->opcode) {
		case ZEND_SWITCH_FREE:
			if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
				zval_ptr_dtor(&EX_T(brk_opline->op1.var).var.ptr);
			}
			break;
		case ZEND_FREE:
			if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
				zendi_zval_dtor(EX_T(brk_opline->op1.var).tmp_var);
			}
			break;
	}
	ZEND_VM_JMP(opline->op1.jmp_addr);
}

case 3600: /*ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zend_class_entry *ce = EX_T(opline->op1.var).class_entry;
	zend_class_entry *iface;

	SAVE_OPLINE();
	if (CACHED_PTR(opline->op2.literal->cache_slot)) {
		iface = CACHED_PTR(opline->op2.literal->cache_slot);
	} else {
		iface = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
		if (UNEXPECTED(iface == NULL)) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
		CACHE_PTR(opline->op2.literal->cache_slot, ce);
	}

	if (UNEXPECTED((iface->ce_flags & ZEND_ACC_INTERFACE) == 0)) {
		zend_error_noreturn(E_ERROR, "%s cannot implement %s - it is not an interface", ce->name, iface->name);
	}
	zend_do_implement_interface(ce, iface TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2726: /*ZEND_FETCH_CLASS_SPEC_TMP_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_TMP_VAR == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_op2;
		zval *class_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (IS_TMP_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		zval_dtor(free_op2.var);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1476: /*ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_TMP_VAR == IS_CONST) {
		function_name = (zval*)(opline->op2.literal+1);
		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(function_name), Z_STRLEN_P(function_name)+1, Z_HASH_P(function_name), (void **) &call->fbc) == FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}
		call->object = NULL;
		call->called_scope = NULL;
		call->is_ctor_call = 0;
		EX(call) = call;
		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		char *function_name_strval, *lcname;
		int function_name_strlen;
		zend_free_op free_op2;

		SAVE_OPLINE();
		function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			function_name_strval = Z_STRVAL_P(function_name);
			function_name_strlen = Z_STRLEN_P(function_name);
			if (function_name_strval[0] == '\\') {
			    function_name_strlen -= 1;
				lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
			} else {
				lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
			}
			if (UNEXPECTED(zend_hash_find(EG(function_table), lcname, function_name_strlen+1, (void **) &call->fbc) == FAILURE)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", function_name_strval);
			}
			efree(lcname);
			zval_dtor(free_op2.var);
			call->object = NULL;
			call->called_scope = NULL;
			call->is_ctor_call = 0;
			EX(call) = call;
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_TMP_VAR != IS_CONST && IS_TMP_VAR != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				Z_ADDREF_P(call->object);
			}
			if (IS_TMP_VAR == IS_VAR && 1 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name;
			} else {
				zval_dtor(free_op2.var);
			}
			call->is_ctor_call = 0;
			EX(call) = call;
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_TMP_VAR != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zend_class_entry *ce;
			zval **method = NULL;
			zval **obj = NULL;

			zend_hash_index_find(Z_ARRVAL_P(function_name), 0, (void **) &obj);
			zend_hash_index_find(Z_ARRVAL_P(function_name), 1, (void **) &method);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_PP(obj) != IS_STRING && Z_TYPE_PP(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_PP(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_PP(obj) == IS_STRING) {
				ce = zend_fetch_class_by_name(Z_STRVAL_PP(obj), Z_STRLEN_PP(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				call->called_scope = ce;
				call->object = NULL;

				if (ce->get_static_method) {
					call->fbc = ce->get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				}
			} else {
				call->object = *obj;
				ce = call->called_scope = Z_OBJCE_PP(obj);

				call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_PP(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					if (!PZVAL_IS_REF(call->object)) {
						Z_ADDREF_P(call->object); /* For $this pointer */
					} else {
						zval *this_ptr;
						ALLOC_ZVAL(this_ptr);
						INIT_PZVAL_COPY(this_ptr, call->object);
						zval_copy_ctor(this_ptr);
						call->object = this_ptr;
					}
				}
			}

			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, Z_STRVAL_PP(method));
			}
			call->is_ctor_call = 0;
			EX(call) = call;
			zval_dtor(free_op2.var);
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


case 2727: /*ZEND_FETCH_CLASS_SPEC_VAR_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_VAR == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_op2;
		zval *class_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1477: /*ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_VAR == IS_CONST) {
		function_name = (zval*)(opline->op2.literal+1);
		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(function_name), Z_STRLEN_P(function_name)+1, Z_HASH_P(function_name), (void **) &call->fbc) == FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}
		call->object = NULL;
		call->called_scope = NULL;
		call->is_ctor_call = 0;
		EX(call) = call;
		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		char *function_name_strval, *lcname;
		int function_name_strlen;
		zend_free_op free_op2;

		SAVE_OPLINE();
		function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			function_name_strval = Z_STRVAL_P(function_name);
			function_name_strlen = Z_STRLEN_P(function_name);
			if (function_name_strval[0] == '\\') {
			    function_name_strlen -= 1;
				lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
			} else {
				lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
			}
			if (UNEXPECTED(zend_hash_find(EG(function_table), lcname, function_name_strlen+1, (void **) &call->fbc) == FAILURE)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", function_name_strval);
			}
			efree(lcname);
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
			call->object = NULL;
			call->called_scope = NULL;
			call->is_ctor_call = 0;
			EX(call) = call;
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_VAR != IS_CONST && IS_VAR != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				Z_ADDREF_P(call->object);
			}
			if (IS_VAR == IS_VAR && (free_op2.var != NULL) &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name;
			} else {
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
			}
			call->is_ctor_call = 0;
			EX(call) = call;
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_VAR != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zend_class_entry *ce;
			zval **method = NULL;
			zval **obj = NULL;

			zend_hash_index_find(Z_ARRVAL_P(function_name), 0, (void **) &obj);
			zend_hash_index_find(Z_ARRVAL_P(function_name), 1, (void **) &method);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_PP(obj) != IS_STRING && Z_TYPE_PP(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_PP(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_PP(obj) == IS_STRING) {
				ce = zend_fetch_class_by_name(Z_STRVAL_PP(obj), Z_STRLEN_PP(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				call->called_scope = ce;
				call->object = NULL;

				if (ce->get_static_method) {
					call->fbc = ce->get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				}
			} else {
				call->object = *obj;
				ce = call->called_scope = Z_OBJCE_PP(obj);

				call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_PP(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					if (!PZVAL_IS_REF(call->object)) {
						Z_ADDREF_P(call->object); /* For $this pointer */
					} else {
						zval *this_ptr;
						ALLOC_ZVAL(this_ptr);
						INIT_PZVAL_COPY(this_ptr, call->object);
						zval_copy_ctor(this_ptr);
						call->object = this_ptr;
					}
				}
			}

			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, Z_STRVAL_PP(method));
			}
			call->is_ctor_call = 0;
			EX(call) = call;
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


case 2728: /*ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_UNUSED == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {

		zval *class_name = NULL;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 2729: /*ZEND_FETCH_CLASS_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_CV == IS_UNUSED) {
		EX_T(opline->result.var).class_entry = zend_fetch_class(NULL, 0, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {

		zval *class_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		if (IS_CV == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				EX_T(opline->result.var).class_entry = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				EX_T(opline->result.var).class_entry = zend_fetch_class_by_name(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->op2.literal + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(opline->op2.literal->cache_slot, EX_T(opline->result.var).class_entry);
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			EX_T(opline->result.var).class_entry = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			EX_T(opline->result.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1479: /*ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_CV == IS_CONST) {
		function_name = (zval*)(opline->op2.literal+1);
		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(function_name), Z_STRLEN_P(function_name)+1, Z_HASH_P(function_name), (void **) &call->fbc) == FAILURE)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
		}
		call->object = NULL;
		call->called_scope = NULL;
		call->is_ctor_call = 0;
		EX(call) = call;
		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		char *function_name_strval, *lcname;
		int function_name_strlen;


		SAVE_OPLINE();
		function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			function_name_strval = Z_STRVAL_P(function_name);
			function_name_strlen = Z_STRLEN_P(function_name);
			if (function_name_strval[0] == '\\') {
			    function_name_strlen -= 1;
				lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
			} else {
				lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
			}
			if (UNEXPECTED(zend_hash_find(EG(function_table), lcname, function_name_strlen+1, (void **) &call->fbc) == FAILURE)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", function_name_strval);
			}
			efree(lcname);

			call->object = NULL;
			call->called_scope = NULL;
			call->is_ctor_call = 0;
			EX(call) = call;
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CV != IS_CONST && IS_CV != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				Z_ADDREF_P(call->object);
			}
			if (IS_CV == IS_VAR && 0 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name;
			} else {

			}
			call->is_ctor_call = 0;
			EX(call) = call;
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CV != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zend_class_entry *ce;
			zval **method = NULL;
			zval **obj = NULL;

			zend_hash_index_find(Z_ARRVAL_P(function_name), 0, (void **) &obj);
			zend_hash_index_find(Z_ARRVAL_P(function_name), 1, (void **) &method);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_PP(obj) != IS_STRING && Z_TYPE_PP(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_PP(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_PP(obj) == IS_STRING) {
				ce = zend_fetch_class_by_name(Z_STRVAL_PP(obj), Z_STRLEN_PP(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				call->called_scope = ce;
				call->object = NULL;

				if (ce->get_static_method) {
					call->fbc = ce->get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(ce, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				}
			} else {
				call->object = *obj;
				ce = call->called_scope = Z_OBJCE_PP(obj);

				call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, Z_STRVAL_PP(method), Z_STRLEN_PP(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_PP(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					if (!PZVAL_IS_REF(call->object)) {
						Z_ADDREF_P(call->object); /* For $this pointer */
					} else {
						zval *this_ptr;
						ALLOC_ZVAL(this_ptr);
						INIT_PZVAL_COPY(this_ptr, call->object);
						zval_copy_ctor(this_ptr);
						call->object = this_ptr;
					}
				}
			}

			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, Z_STRVAL_PP(method));
			}
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


case 300: /*ZEND_BW_NOT_SPEC_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_not_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 325: /*ZEND_BOOL_NOT_SPEC_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_not_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1000: /*ZEND_ECHO_SPEC_CONST_HANDLER*/ ZEND_ECHO_SPEC_CONST_LABEL:
{
	USE_OPLINE

	zval z_copy;
	zval *z;

	SAVE_OPLINE();
	z = opline->op1.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) &&
	    Z_OBJ_HT_P(z)->get_method != NULL) {
	    if (IS_CONST == IS_TMP_VAR) {
	    	INIT_PZVAL(z);
	    }
		if (zend_std_cast_object_tostring(z, &z_copy, IS_STRING TSRMLS_CC) == SUCCESS) {
			zend_print_variable(&z_copy);
			zval_dtor(&z_copy);
		} else {
			zend_print_variable(z);
		}
	} else {
		zend_print_variable(z);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1025: /*ZEND_PRINT_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	ZVAL_LONG(&EX_T(opline->result.var).tmp_var, 1);
	goto ZEND_ECHO_SPEC_CONST_LABEL;
}

case 1075: /*ZEND_JMPZ_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

case 1100: /*ZEND_JMPNZ_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

case 1125: /*ZEND_JMPZNZ_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

case 1150: /*ZEND_JMPZ_EX_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1175: /*ZEND_JMPNZ_EX_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1500: /*ZEND_DO_FCALL_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *fname = opline->op1.zv;
	call_slot *call = EX(call_slots) + opline->op2.num;

	if (CACHED_PTR(opline->op1.literal->cache_slot)) {
		EX(function_state).function = CACHED_PTR(opline->op1.literal->cache_slot);
	} else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(fname), Z_STRLEN_P(fname)+1, Z_HASH_P(fname), (void **) &EX(function_state).function)==FAILURE)) {
	    SAVE_OPLINE();
		zend_error_noreturn(E_ERROR, "Call to undefined function %s()", fname->value.str.val);
	} else {
		CACHE_PTR(opline->op1.literal->cache_slot, EX(function_state).function);
	}
	call->fbc = EX(function_state).function;
	call->object = NULL;
	call->called_scope = NULL;
	call->is_ctor_call = 0;
	EX(call) = call;

	goto zend_do_fcall_common_helper_SPEC;
}

case 1550: /*ZEND_RETURN_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zval *retval_ptr;


	SAVE_OPLINE();
	retval_ptr = opline->op1.zv;

	if (!EG(return_value_ptr_ptr)) {
		if (IS_CONST == IS_TMP_VAR) {

		}
	} else if (!0) { /* Not a temp var */
		if (*EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}
		if (IS_CONST == IS_CONST ||
		    (PZVAL_IS_REF(retval_ptr) && Z_REFCOUNT_P(retval_ptr) > 0)) {
			zval *ret;

			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, retval_ptr);
			zval_copy_ctor(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else if ((IS_CONST == IS_CV || IS_CONST == IS_VAR) &&
		           retval_ptr == &EG(uninitialized_zval)) {
			zval *ret;

			ALLOC_INIT_ZVAL(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else {
			*EG(return_value_ptr_ptr) = retval_ptr;
			Z_ADDREF_P(retval_ptr);
		}
	} else {
		zval *ret;

		if (*EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}

		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, retval_ptr);
		*EG(return_value_ptr_ptr) = ret;
	}

	goto zend_leave_helper_SPEC;
}

case 2775: /*ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zval *retval_ptr;
	zval **retval_ptr_ptr;


	SAVE_OPLINE();

	do {
		if (EG(return_value_ptr_ptr) && *EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}

		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = opline->op1.zv;
			if (!EG(return_value_ptr_ptr)) {
				if (IS_CONST == IS_TMP_VAR) {

				}
			} else if (!0) { /* Not a temp var */
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				zval_copy_ctor(ret);
				*EG(return_value_ptr_ptr) = ret;
			} else {
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				*EG(return_value_ptr_ptr) = ret;
			}
			break;
		}

		retval_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(retval_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_CONST == IS_VAR && !Z_ISREF_PP(retval_ptr_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    EX_T(opline->op1.var).var.fcall_returned_reference) {
			} else if (EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EG(return_value_ptr_ptr)) {
					retval_ptr = *retval_ptr_ptr;
					*EG(return_value_ptr_ptr) = retval_ptr;
					Z_ADDREF_P(retval_ptr);
				}
				break;
			}
		}

		if (EG(return_value_ptr_ptr)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr);
			Z_ADDREF_PP(retval_ptr_ptr);

			*EG(return_value_ptr_ptr) = *retval_ptr_ptr;
		}
	} while (0);

	goto zend_leave_helper_SPEC;
}

case 2700: /*ZEND_THROW_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zval *value;
	zval *exception;


	SAVE_OPLINE();
	value = opline->op1.zv;

	if (IS_CONST == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}
	zend_exception_save(TSRMLS_C);
	/* Not sure if a complete copy is what we want here */
	ALLOC_ZVAL(exception);
	INIT_PZVAL_COPY(exception, value);
	if (!0) {
		zval_copy_ctor(exception);
	}

	zend_throw_exception_object(exception TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	HANDLE_EXCEPTION();
}

case 1625: /*ZEND_SEND_VAL_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (opline->extended_value==ZEND_DO_FCALL_BY_NAME
		&& ARG_MUST_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
			zend_error_noreturn(E_ERROR, "Cannot pass parameter %d by reference", opline->op2.opline_num);
	}
	{
		zval *valptr;
		zval *value;


		value = opline->op1.zv;

		ALLOC_ZVAL(valptr);
		INIT_PZVAL_COPY(valptr, value);
		if (!0) {
			zval_copy_ctor(valptr);
		}
		zend_vm_stack_push(valptr TSRMLS_CC);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1300: /*ZEND_BOOL_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *retval = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(opline->op1.zv));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2750: /*ZEND_CLONE_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = opline->op1.zv;

	if (IS_CONST == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			AI_SET_PTR(&EX_T(opline->result.var), retval);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 525: /*ZEND_CAST_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *expr;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	expr = opline->op1.zv;

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!0) {
			zendi_zval_copy_ctor(*result);
		}
	}
	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (0) {

				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!0) {
					zendi_zval_copy_ctor(*result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1825: /*ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER*/
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;

	zval *inc_filename;
	zval *tmp_inc_filename = NULL;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = opline->op1.zv;

	if (inc_filename->type!=IS_STRING) {
		MAKE_STD_ZVAL(tmp_inc_filename);
		ZVAL_COPY_VALUE(tmp_inc_filename, inc_filename);
		zval_copy_ctor(tmp_inc_filename);
		convert_to_string(tmp_inc_filename);
		inc_filename = tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_exists(&EG(included_files), resolved_path, strlen(resolved_path)+1);
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==SUCCESS) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (tmp_inc_filename) {
		zval_ptr_dtor(&tmp_inc_filename);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			EX_T(opline->result.var).var.ptr = NULL;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			EG(return_value_ptr_ptr) = EX_T(opline->result.var).var.ptr_ptr;
		} else {
			EG(return_value_ptr_ptr) = NULL;
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		ZVAL_BOOL(retval, failure_retval);
		INIT_PZVAL(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1925: /*ZEND_FE_RESET_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *array_ptr, **array_ptr_ptr;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_CONST == IS_CV || IS_CONST == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr_ptr = NULL;
		if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {
			MAKE_STD_ZVAL(array_ptr);
			ZVAL_NULL(array_ptr);
		} else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_PP(array_ptr_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_PP(array_ptr_ptr);
			if (!ce || ce->get_iterator == NULL) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				Z_ADDREF_PP(array_ptr_ptr);
			}
			array_ptr = *array_ptr_ptr;
		} else {
			if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					Z_SET_ISREF_PP(array_ptr_ptr);
				}
			}
			array_ptr = *array_ptr_ptr;
			Z_ADDREF_P(array_ptr);
		}
	} else {
		array_ptr = opline->op1.zv;
		if (0) { /* IS_TMP_VAR */
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			array_ptr = tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ptr);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				Z_ADDREF_P(array_ptr);
			}
		} else if (IS_CONST == IS_CONST ||
		           ((IS_CONST == IS_CV || IS_CONST == IS_VAR) &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 1)) {
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			zval_copy_ctor(tmp);
			array_ptr = tmp;
		} else {
			Z_ADDREF_P(array_ptr);
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (iter && EXPECTED(EG(exception) == NULL)) {
			array_ptr = zend_iterator_wrap(iter TSRMLS_CC);
		} else {

			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	EX_T(opline->result.var).fe.ptr = array_ptr;

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array_ptr);

				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&array_ptr);

			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = zend_objects_get_address(array_ptr TSRMLS_CC);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				char *str_key;
				uint str_key_len;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);
				if (key_type != HASH_KEY_NON_EXISTANT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key, str_key_len-1 TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, &EX_T(opline->result.var).fe.fe_pos);
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1975: /*ZEND_EXIT_SPEC_CONST_HANDLER*/
{
#if 0 || (IS_CONST != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CONST != IS_UNUSED) {

		zval *ptr = opline->op1.zv;

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}

	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

case 3800: /*ZEND_JMP_SET_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = opline->op1.zv;

	if (i_zend_is_true(value)) {
		ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
		if (!0) {
			zendi_zval_copy_ctor(EX_T(opline->result.var).tmp_var);
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3950: /*ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *value, *ret;

	SAVE_OPLINE();
	value = opline->op1.zv;

	if (i_zend_is_true(value)) {
		if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
			Z_ADDREF_P(value);
			EX_T(opline->result.var).var.ptr = value;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		} else {
			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, value);
			EX_T(opline->result.var).var.ptr = ret;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			if (!0) {
				zval_copy_ctor(EX_T(opline->result.var).var.ptr);
			}
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 550: /*ZEND_QM_ASSIGN_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = opline->op1.zv;

	ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
	if (!0) {
		zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3925: /*ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER*/
{
	USE_OPLINE

	zval *value, *ret;

	SAVE_OPLINE();
	value = opline->op1.zv;

	if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		Z_ADDREF_P(value);
		EX_T(opline->result.var).var.ptr = value;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	} else {
		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, value);
		EX_T(opline->result.var).var.ptr = ret;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		if (!0) {
			zval_copy_ctor(EX_T(opline->result.var).var.ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 25: /*ZEND_ADD_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 50: /*ZEND_SUB_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 75: /*ZEND_MUL_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 100: /*ZEND_DIV_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 125: /*ZEND_MOD_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 150: /*ZEND_SL_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 175: /*ZEND_SR_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 200: /*ZEND_CONCAT_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 375: /*ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 400: /*ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 425: /*ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 450: /*ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 475: /*ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 500: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 225: /*ZEND_BW_OR_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 250: /*ZEND_BW_AND_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 275: /*ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 350: /*ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_fetch_var_address_helper_SPEC_CONST_CONST:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = opline->op1.zv;

 	if (IS_CONST != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CONST == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CONST != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CONST == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CONST != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2000: /*ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CONST_CONST;
}

case 2075: /*ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_CONST_CONST;
}

case 2150: /*ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_CONST_CONST;
}

case 2300: /*ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CONST_CONST;
}

case 2375: /*ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_CONST_CONST;
}

case 2225: /*ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_CONST_CONST;
}

case 2025: /*ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_CONST != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_CONST == IS_TMP_VAR || IS_CONST == IS_CONST) {
		zval *container = opline->op1.zv;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);


	} else {
		container = NULL;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);


	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2450: /*ZEND_FETCH_DIM_TMP_VAR_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_ARRAY)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
	} else {

		zval *value = *zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		PZVAL_LOCK(value);
		AI_SET_PTR(&EX_T(opline->result.var), value);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2825: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_CONST != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_CONST == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = opline->op2.zv;

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1200: /*ZEND_CASE_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	if (IS_CONST==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 opline->op1.zv,
				 opline->op2.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2475: /*ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CONST == IS_UNUSED) {
		zend_constant *c;
		zval *retval;

		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			c = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if ((c = zend_quick_get_constant(opline->op2.literal + 1, opline->extended_value TSRMLS_CC)) == NULL) {
			if ((opline->extended_value & IS_CONSTANT_UNQUALIFIED) != 0) {
				char *actual = (char *)zend_memrchr(Z_STRVAL_P(opline->op2.zv), '\\', Z_STRLEN_P(opline->op2.zv));
				if(!actual) {
					actual = Z_STRVAL_P(opline->op2.zv);
				} else {
					actual++;
				}
				/* non-qualified constant - allow text substitution */
				zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'", actual, actual);
				ZVAL_STRINGL(&EX_T(opline->result.var).tmp_var, actual, Z_STRLEN_P(opline->op2.zv)-(actual - Z_STRVAL_P(opline->op2.zv)), 1);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else {
				zend_error_noreturn(E_ERROR, "Undefined constant '%s'", Z_STRVAL_P(opline->op2.zv));
			}
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, c);
		}
		retval = &EX_T(opline->result.var).tmp_var;
		ZVAL_COPY_VALUE(retval, &c->value);
		zval_copy_ctor(retval);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		/* class constant */
		zend_class_entry *ce;
		zval **value;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				value = CACHED_PTR(opline->op2.literal->cache_slot);
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else if (CACHED_PTR(opline->op1.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op1.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op1.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op1.var).class_entry;
			if ((value = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce)) != NULL) {
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
		}

		if (EXPECTED(zend_hash_quick_find(&ce->constants_table, Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv)+1, Z_HASH_P(opline->op2.zv), (void **) &value) == SUCCESS)) {
			if (Z_TYPE_PP(value) == IS_CONSTANT_ARRAY ||
			    (Z_TYPE_PP(value) & IS_CONSTANT_TYPE_MASK) == IS_CONSTANT) {
				zend_class_entry *old_scope = EG(scope);

				EG(scope) = ce;
				zval_update_constant(value, (void *) 1 TSRMLS_CC);
				EG(scope) = old_scope;
			}
			if (IS_CONST == IS_CONST) {
				CACHE_PTR(opline->op2.literal->cache_slot, value);
			} else {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, value);
			}
			ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
			zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
		} else {
			zend_error_noreturn(E_ERROR, "Undefined class constant '%s'", Z_STRVAL_P(opline->op2.zv));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1800: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CONST_CONST;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CONST_CONST:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CONST_CONST);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1775: /*ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_LABEL;
#endif
	}
}

case 1850: /*ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = opline->op1.zv;

	if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CONST != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2850: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = opline->op1.zv;

		if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CONST != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3575: /*ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	zval *name;
	zval *val;
	zend_constant c;

	SAVE_OPLINE();
	name  = opline->op1.zv;
	val   = opline->op2.zv;

	if ((Z_TYPE_P(val) & IS_CONSTANT_TYPE_MASK) == IS_CONSTANT || Z_TYPE_P(val) == IS_CONSTANT_ARRAY) {
		zval tmp;
		zval *tmp_ptr = &tmp;

		ZVAL_COPY_VALUE(&tmp, val);
		if (Z_TYPE_P(val) == IS_CONSTANT_ARRAY) {
			zval_copy_ctor(&tmp);
		}
		INIT_PZVAL(&tmp);
		zval_update_constant(&tmp_ptr, NULL TSRMLS_CC);
		c.value = *tmp_ptr;
	} else {
		INIT_PZVAL_COPY(&c.value, val);
		zval_copy_ctor(&c.value);
	}
	c.flags = CONST_CS; /* non persistent, case sensetive */
	c.name = IS_INTERNED(Z_STRVAL_P(name)) ? Z_STRVAL_P(name) : zend_strndup(Z_STRVAL_P(name), Z_STRLEN_P(name));
	c.name_len = Z_STRLEN_P(name)+1;
	c.module_number = PHP_USER_CONSTANT;

	if (zend_register_constant(&c TSRMLS_CC) == FAILURE) {
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 4000: /*ZEND_YIELD_SPEC_CONST_CONST_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 26: /*ZEND_ADD_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 51: /*ZEND_SUB_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 76: /*ZEND_MUL_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 101: /*ZEND_DIV_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 126: /*ZEND_MOD_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 151: /*ZEND_SL_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 176: /*ZEND_SR_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 201: /*ZEND_CONCAT_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 376: /*ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 401: /*ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 426: /*ZEND_IS_EQUAL_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 451: /*ZEND_IS_NOT_EQUAL_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 476: /*ZEND_IS_SMALLER_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 501: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 226: /*ZEND_BW_OR_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 251: /*ZEND_BW_AND_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 276: /*ZEND_BW_XOR_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 351: /*ZEND_BOOL_XOR_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2026: /*ZEND_FETCH_DIM_R_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_CONST != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_CONST == IS_TMP_VAR || IS_CONST == IS_CONST) {
		zval *container = opline->op1.zv;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);

	} else {
		container = NULL;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2826: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_TMP_VAR == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_TMP_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_TMP_VAR != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;
		zend_free_op free_op2;

		if (IS_TMP_VAR == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_TMP_VAR != IS_CONST) {
			zval_dtor(free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1201: /*ZEND_CASE_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	if (IS_CONST==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 opline->op1.zv,
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1801: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CONST_TMP;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CONST_TMP:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CONST_TMP);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1776: /*ZEND_INIT_ARRAY_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_LABEL;
#endif
	}
}

case 4001: /*ZEND_YIELD_SPEC_CONST_TMP_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 27: /*ZEND_ADD_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 52: /*ZEND_SUB_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 77: /*ZEND_MUL_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 102: /*ZEND_DIV_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 127: /*ZEND_MOD_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 152: /*ZEND_SL_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 177: /*ZEND_SR_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 202: /*ZEND_CONCAT_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 377: /*ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 402: /*ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 427: /*ZEND_IS_EQUAL_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 452: /*ZEND_IS_NOT_EQUAL_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 477: /*ZEND_IS_SMALLER_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 502: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 227: /*ZEND_BW_OR_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 252: /*ZEND_BW_AND_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 277: /*ZEND_BW_XOR_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 352: /*ZEND_BOOL_XOR_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_fetch_var_address_helper_SPEC_CONST_VAR:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = opline->op1.zv;

 	if (IS_CONST != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CONST == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CONST != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CONST == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CONST != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2002: /*ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CONST_VAR;
}

case 2077: /*ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_CONST_VAR;
}

case 2152: /*ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_CONST_VAR;
}

case 2302: /*ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CONST_VAR;
}

case 2377: /*ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_CONST_VAR;
}

case 2227: /*ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_CONST_VAR;
}

case 2027: /*ZEND_FETCH_DIM_R_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_CONST != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_CONST == IS_TMP_VAR || IS_CONST == IS_CONST) {
		zval *container = opline->op1.zv;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	} else {
		container = NULL;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2827: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_VAR == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_VAR != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;
		zend_free_op free_op2;

		if (IS_VAR == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_VAR != IS_CONST) {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1202: /*ZEND_CASE_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	if (IS_CONST==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 opline->op1.zv,
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1802: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CONST_VAR;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CONST_VAR:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CONST_VAR);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1777: /*ZEND_INIT_ARRAY_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_LABEL;
#endif
	}
}

case 1852: /*ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = opline->op1.zv;

	if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CONST != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2852: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = opline->op1.zv;

		if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CONST != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 4002: /*ZEND_YIELD_SPEC_CONST_VAR_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

zend_fetch_var_address_helper_SPEC_CONST_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = opline->op1.zv;

 	if (IS_CONST != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CONST == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CONST != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CONST == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CONST != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2003: /*ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CONST_UNUSED;
}

case 2078: /*ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_CONST_UNUSED;
}

case 2153: /*ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_CONST_UNUSED;
}

case 2303: /*ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CONST_UNUSED;
}

case 2378: /*ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_CONST_UNUSED;
}

case 2228: /*ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_CONST_UNUSED;
}

case 2828: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_UNUSED != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_UNUSED == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = NULL;

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_UNUSED == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_UNUSED == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1803: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CONST_UNUSED;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CONST_UNUSED:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_UNUSED == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CONST_UNUSED);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1778: /*ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_LABEL;
#endif
	}
}

case 1853: /*ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = opline->op1.zv;

	if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CONST != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2853: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = opline->op1.zv;

		if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CONST == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CONST != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3828: /*ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER*/
{
	USE_OPLINE
	zend_function *op_array;

	SAVE_OPLINE();

	if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), Z_HASH_P(opline->op1.zv), (void *) &op_array) == FAILURE) ||
	    UNEXPECTED(op_array->type != ZEND_USER_FUNCTION)) {
		zend_error_noreturn(E_ERROR, "Base lambda function for closure not found");
	}

	zend_create_closure(&EX_T(opline->result.var).tmp_var, (zend_function *) op_array, EG(scope), EG(This) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 4003: /*ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 29: /*ZEND_ADD_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 54: /*ZEND_SUB_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 79: /*ZEND_MUL_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 104: /*ZEND_DIV_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 129: /*ZEND_MOD_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 154: /*ZEND_SL_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 179: /*ZEND_SR_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 204: /*ZEND_CONCAT_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 379: /*ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 404: /*ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 429: /*ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 454: /*ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 479: /*ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 504: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 229: /*ZEND_BW_OR_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 254: /*ZEND_BW_AND_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 279: /*ZEND_BW_XOR_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 354: /*ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2029: /*ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE

	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_CONST != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_CONST == IS_TMP_VAR || IS_CONST == IS_CONST) {
		zval *container = opline->op1.zv;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);


	} else {
		container = NULL;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);


	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2829: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_CV == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_CONST != IS_CONST &&
	           IS_CV == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_CV != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_CV == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_CONST == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2679: /*ZEND_CATCH_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE
	zend_class_entry *ce, *catch_ce;
	zval *exception;

	SAVE_OPLINE();
	/* Check whether an exception has been thrown, if not, jump over code */
	zend_exception_restore(TSRMLS_C);
	if (EG(exception) == NULL) {
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
	if (CACHED_PTR(opline->op1.literal->cache_slot)) {
		catch_ce = CACHED_PTR(opline->op1.literal->cache_slot);
	} else {
		catch_ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, ZEND_FETCH_CLASS_NO_AUTOLOAD TSRMLS_CC);

		CACHE_PTR(opline->op1.literal->cache_slot, catch_ce);
	}
	ce = Z_OBJCE_P(EG(exception));

#ifdef HAVE_DTRACE
	if (DTRACE_EXCEPTION_CAUGHT_ENABLED()) {
		DTRACE_EXCEPTION_CAUGHT(ce->name);
	}
#endif /* HAVE_DTRACE */

	if (ce != catch_ce) {
		if (!instanceof_function(ce, catch_ce TSRMLS_CC)) {
			if (opline->result.num) {
				zend_throw_exception_internal(NULL TSRMLS_CC);
				HANDLE_EXCEPTION();
			}
			ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
			ZEND_VM_CONTINUE(); /* CHECK_ME */
		}
	}

	exception = EG(exception);
	if (!EG(active_symbol_table)) {
		if (EX_CV(opline->op2.var)) {
			zval_ptr_dtor(EX_CV(opline->op2.var));
		}
		EX_CV(opline->op2.var) = (zval**)EX_CV_NUM(execute_data, EX(op_array)->last_var + opline->op2.var);
		*EX_CV(opline->op2.var) = EG(exception);
	} else {
		zend_compiled_variable *cv = &CV_DEF_OF(opline->op2.var);
		zend_hash_quick_update(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value,
		    &EG(exception), sizeof(zval *), (void**)&EX_CV(opline->op2.var));
	}
	if (UNEXPECTED(EG(exception) != exception)) {
		Z_ADDREF_P(EG(exception));
		HANDLE_EXCEPTION();
	} else {
		EG(exception) = NULL;
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1204: /*ZEND_CASE_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	if (IS_CONST==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 opline->op1.zv,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1804: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=opline->op1.zv;
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CONST == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CONST_CV;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CONST_CV:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CONST_CV);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1779: /*ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_LABEL;
#endif
	}
}

case 4004: /*ZEND_YIELD_SPEC_CONST_CV_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 305: /*ZEND_BW_NOT_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 330: /*ZEND_BOOL_NOT_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1005: /*ZEND_ECHO_SPEC_TMP_HANDLER*/ ZEND_ECHO_SPEC_TMP_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval z_copy;
	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) &&
	    Z_OBJ_HT_P(z)->get_method != NULL) {
	    if (IS_TMP_VAR == IS_TMP_VAR) {
	    	INIT_PZVAL(z);
	    }
		if (zend_std_cast_object_tostring(z, &z_copy, IS_STRING TSRMLS_CC) == SUCCESS) {
			zend_print_variable(&z_copy);
			zval_dtor(&z_copy);
		} else {
			zend_print_variable(z);
		}
	} else {
		zend_print_variable(z);
	}

	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1030: /*ZEND_PRINT_SPEC_TMP_HANDLER*/
{
	USE_OPLINE

	ZVAL_LONG(&EX_T(opline->result.var).tmp_var, 1);
	goto ZEND_ECHO_SPEC_TMP_LABEL;
}

case 1080: /*ZEND_JMPZ_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

case 1105: /*ZEND_JMPNZ_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

case 1130: /*ZEND_JMPZNZ_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

case 1155: /*ZEND_JMPZ_EX_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1180: /*ZEND_JMPNZ_EX_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1755: /*ZEND_FREE_SPEC_TMP_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_TMP_VAR) {
		zendi_zval_dtor(EX_T(opline->op1.var).tmp_var);
	} else {
		zval_ptr_dtor(&EX_T(opline->op1.var).var.ptr);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1555: /*ZEND_RETURN_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zval *retval_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();
	retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (!EG(return_value_ptr_ptr)) {
		if (IS_TMP_VAR == IS_TMP_VAR) {
			zval_dtor(free_op1.var);
		}
	} else if (!1) { /* Not a temp var */
		if (*EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}
		if (IS_TMP_VAR == IS_CONST ||
		    (PZVAL_IS_REF(retval_ptr) && Z_REFCOUNT_P(retval_ptr) > 0)) {
			zval *ret;

			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, retval_ptr);
			zval_copy_ctor(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else if ((IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) &&
		           retval_ptr == &EG(uninitialized_zval)) {
			zval *ret;

			ALLOC_INIT_ZVAL(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else {
			*EG(return_value_ptr_ptr) = retval_ptr;
			Z_ADDREF_P(retval_ptr);
		}
	} else {
		zval *ret;

		if (*EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}

		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, retval_ptr);
		*EG(return_value_ptr_ptr) = ret;
	}

	goto zend_leave_helper_SPEC;
}

case 2780: /*ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zval *retval_ptr;
	zval **retval_ptr_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();

	do {
		if (EG(return_value_ptr_ptr) && *EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}

		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			if (!EG(return_value_ptr_ptr)) {
				if (IS_TMP_VAR == IS_TMP_VAR) {
					zval_dtor(free_op1.var);
				}
			} else if (!1) { /* Not a temp var */
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				zval_copy_ctor(ret);
				*EG(return_value_ptr_ptr) = ret;
			} else {
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				*EG(return_value_ptr_ptr) = ret;
			}
			break;
		}

		retval_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(retval_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(retval_ptr_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    EX_T(opline->op1.var).var.fcall_returned_reference) {
			} else if (EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EG(return_value_ptr_ptr)) {
					retval_ptr = *retval_ptr_ptr;
					*EG(return_value_ptr_ptr) = retval_ptr;
					Z_ADDREF_P(retval_ptr);
				}
				break;
			}
		}

		if (EG(return_value_ptr_ptr)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr);
			Z_ADDREF_PP(retval_ptr_ptr);

			*EG(return_value_ptr_ptr) = *retval_ptr_ptr;
		}
	} while (0);

	goto zend_leave_helper_SPEC;
}

case 2705: /*ZEND_THROW_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zval *value;
	zval *exception;
	zend_free_op free_op1;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}
	zend_exception_save(TSRMLS_C);
	/* Not sure if a complete copy is what we want here */
	ALLOC_ZVAL(exception);
	INIT_PZVAL_COPY(exception, value);
	if (!1) {
		zval_copy_ctor(exception);
	}

	zend_throw_exception_object(exception TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	HANDLE_EXCEPTION();
}

case 1630: /*ZEND_SEND_VAL_SPEC_TMP_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (opline->extended_value==ZEND_DO_FCALL_BY_NAME
		&& ARG_MUST_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
			zend_error_noreturn(E_ERROR, "Cannot pass parameter %d by reference", opline->op2.opline_num);
	}
	{
		zval *valptr;
		zval *value;
		zend_free_op free_op1;

		value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		ALLOC_ZVAL(valptr);
		INIT_PZVAL_COPY(valptr, value);
		if (!1) {
			zval_copy_ctor(valptr);
		}
		zend_vm_stack_push(valptr TSRMLS_CC);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1305: /*ZEND_BOOL_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *retval = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC)));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2755: /*ZEND_CLONE_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			AI_SET_PTR(&EX_T(opline->result.var), retval);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 530: /*ZEND_CAST_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	expr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!1) {
			zendi_zval_copy_ctor(*result);
		}
	}
	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (1) {
					zval_dtor(free_op1.var);
				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!1) {
					zendi_zval_copy_ctor(*result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1830: /*ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;
	zend_free_op free_op1;
	zval *inc_filename;
	zval *tmp_inc_filename = NULL;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (inc_filename->type!=IS_STRING) {
		MAKE_STD_ZVAL(tmp_inc_filename);
		ZVAL_COPY_VALUE(tmp_inc_filename, inc_filename);
		zval_copy_ctor(tmp_inc_filename);
		convert_to_string(tmp_inc_filename);
		inc_filename = tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_exists(&EG(included_files), resolved_path, strlen(resolved_path)+1);
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==SUCCESS) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (tmp_inc_filename) {
		zval_ptr_dtor(&tmp_inc_filename);
	}
	zval_dtor(free_op1.var);
	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			EX_T(opline->result.var).var.ptr = NULL;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			EG(return_value_ptr_ptr) = EX_T(opline->result.var).var.ptr_ptr;
		} else {
			EG(return_value_ptr_ptr) = NULL;
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		ZVAL_BOOL(retval, failure_retval);
		INIT_PZVAL(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1930: /*ZEND_FE_RESET_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *array_ptr, **array_ptr_ptr;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr_ptr = NULL;
		if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {
			MAKE_STD_ZVAL(array_ptr);
			ZVAL_NULL(array_ptr);
		} else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_PP(array_ptr_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_PP(array_ptr_ptr);
			if (!ce || ce->get_iterator == NULL) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				Z_ADDREF_PP(array_ptr_ptr);
			}
			array_ptr = *array_ptr_ptr;
		} else {
			if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					Z_SET_ISREF_PP(array_ptr_ptr);
				}
			}
			array_ptr = *array_ptr_ptr;
			Z_ADDREF_P(array_ptr);
		}
	} else {
		array_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* IS_TMP_VAR */
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			array_ptr = tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ptr);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				Z_ADDREF_P(array_ptr);
			}
		} else if (IS_TMP_VAR == IS_CONST ||
		           ((IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 1)) {
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			zval_copy_ctor(tmp);
			array_ptr = tmp;
		} else {
			Z_ADDREF_P(array_ptr);
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (iter && EXPECTED(EG(exception) == NULL)) {
			array_ptr = zend_iterator_wrap(iter TSRMLS_CC);
		} else {

			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	EX_T(opline->result.var).fe.ptr = array_ptr;

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array_ptr);

				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&array_ptr);

			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = zend_objects_get_address(array_ptr TSRMLS_CC);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				char *str_key;
				uint str_key_len;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);
				if (key_type != HASH_KEY_NON_EXISTANT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key, str_key_len-1 TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, &EX_T(opline->result.var).fe.fe_pos);
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1980: /*ZEND_EXIT_SPEC_TMP_HANDLER*/
{
#if 0 || (IS_TMP_VAR != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;
		zval *ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}
		zval_dtor(free_op1.var);
	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

case 1455: /*ZEND_END_SILENCE_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zval restored_error_reporting;

	SAVE_OPLINE();
	if (!EG(error_reporting) && Z_LVAL(EX_T(opline->op1.var).tmp_var) != 0) {
		Z_TYPE(restored_error_reporting) = IS_LONG;
		Z_LVAL(restored_error_reporting) = Z_LVAL(EX_T(opline->op1.var).tmp_var);
		EG(error_reporting) = Z_LVAL(restored_error_reporting);
		convert_to_string(&restored_error_reporting);
		if (EXPECTED(EG(error_reporting_ini_entry) != NULL)) {
			if (EXPECTED(EG(error_reporting_ini_entry)->modified &&
			    EG(error_reporting_ini_entry)->value != EG(error_reporting_ini_entry)->orig_value)) {
				efree(EG(error_reporting_ini_entry)->value);
			}
			EG(error_reporting_ini_entry)->value = Z_STRVAL(restored_error_reporting);
			EG(error_reporting_ini_entry)->value_length = Z_STRLEN(restored_error_reporting);
		} else {
			zendi_zval_dtor(restored_error_reporting);
		}
	}
	if (EX(old_error_reporting) == &EX_T(opline->op1.var).tmp_var) {
		EX(old_error_reporting) = NULL;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3805: /*ZEND_JMP_SET_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value)) {
		ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
		if (!1) {
			zendi_zval_copy_ctor(EX_T(opline->result.var).tmp_var);
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3955: /*ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value)) {
		if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
			Z_ADDREF_P(value);
			EX_T(opline->result.var).var.ptr = value;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		} else {
			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, value);
			EX_T(opline->result.var).var.ptr = ret;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			if (!1) {
				zval_copy_ctor(EX_T(opline->result.var).var.ptr);
			}
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 555: /*ZEND_QM_ASSIGN_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
	if (!1) {
		zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3930: /*ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		Z_ADDREF_P(value);
		EX_T(opline->result.var).var.ptr = value;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	} else {
		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, value);
		EX_T(opline->result.var).var.ptr = ret;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		if (!1) {
			zval_copy_ctor(EX_T(opline->result.var).var.ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3455: /*ZEND_INSTANCEOF_SPEC_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (Z_TYPE_P(expr) == IS_OBJECT && Z_OBJ_HT_P(expr)->get_class_entry) {
		result = instanceof_function(Z_OBJCE_P(expr), EX_T(opline->op2.var).class_entry TSRMLS_CC);
	} else {
		result = 0;
	}
	ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, result);
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 30: /*ZEND_ADD_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 55: /*ZEND_SUB_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 80: /*ZEND_MUL_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 105: /*ZEND_DIV_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 130: /*ZEND_MOD_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 155: /*ZEND_SL_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 180: /*ZEND_SR_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 205: /*ZEND_CONCAT_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 380: /*ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 405: /*ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 430: /*ZEND_IS_EQUAL_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 455: /*ZEND_IS_NOT_EQUAL_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 480: /*ZEND_IS_SMALLER_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 505: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 230: /*ZEND_BW_OR_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 255: /*ZEND_BW_AND_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 280: /*ZEND_BW_XOR_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 355: /*ZEND_BOOL_XOR_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_fetch_var_address_helper_SPEC_TMP_CONST:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_TMP_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		zval_dtor(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_TMP_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_TMP_VAR != IS_TMP_VAR) {
					zval_dtor(free_op1.var);
				}
				break;
			case ZEND_FETCH_LOCAL:
				zval_dtor(free_op1.var);
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_TMP_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2005: /*ZEND_FETCH_R_SPEC_TMP_CONST_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_TMP_CONST;
}

case 2080: /*ZEND_FETCH_W_SPEC_TMP_CONST_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_TMP_CONST;
}

case 2155: /*ZEND_FETCH_RW_SPEC_TMP_CONST_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_TMP_CONST;
}

case 2305: /*ZEND_FETCH_FUNC_ARG_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_TMP_CONST;
}

case 2380: /*ZEND_FETCH_UNSET_SPEC_TMP_CONST_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_TMP_CONST;
}

case 2230: /*ZEND_FETCH_IS_SPEC_TMP_CONST_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_TMP_CONST;
}

case 2030: /*ZEND_FETCH_DIM_R_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_TMP_VAR != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_TMP_VAR == IS_TMP_VAR || IS_TMP_VAR == IS_CONST) {
		zval *container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		zval_dtor(free_op1.var);
	} else {
		container = NULL;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);


	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2455: /*ZEND_FETCH_DIM_TMP_VAR_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_ARRAY)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
	} else {

		zval *value = *zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		PZVAL_LOCK(value);
		AI_SET_PTR(&EX_T(opline->result.var), value);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1355: /*ZEND_ADD_CHAR_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zval *str = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_char_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_char_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

case 1380: /*ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zval *str = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_string_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

case 2805: /*ZEND_INIT_METHOD_CALL_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1205: /*ZEND_CASE_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_TMP_VAR==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 opline->op2.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1805: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_TMP_CONST;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_TMP_CONST:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_TMP_CONST);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1780: /*ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_LABEL;
#endif
	}
}

case 1855: /*ZEND_UNSET_VAR_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2855: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_dtor(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 4005: /*ZEND_YIELD_SPEC_TMP_CONST_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 31: /*ZEND_ADD_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 56: /*ZEND_SUB_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 81: /*ZEND_MUL_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 106: /*ZEND_DIV_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 131: /*ZEND_MOD_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 156: /*ZEND_SL_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 181: /*ZEND_SR_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 206: /*ZEND_CONCAT_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 381: /*ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 406: /*ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 431: /*ZEND_IS_EQUAL_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 456: /*ZEND_IS_NOT_EQUAL_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 481: /*ZEND_IS_SMALLER_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 506: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 231: /*ZEND_BW_OR_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 256: /*ZEND_BW_AND_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 281: /*ZEND_BW_XOR_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 356: /*ZEND_BOOL_XOR_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2031: /*ZEND_FETCH_DIM_R_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_TMP_VAR != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_TMP_VAR == IS_TMP_VAR || IS_TMP_VAR == IS_CONST) {
		zval *container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);
		zval_dtor(free_op1.var);
	} else {
		container = NULL;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1406: /*ZEND_ADD_VAR_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2806: /*ZEND_INIT_METHOD_CALL_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1206: /*ZEND_CASE_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	if (IS_TMP_VAR==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1806: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_TMP_TMP;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_TMP_TMP:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_TMP_TMP);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1781: /*ZEND_INIT_ARRAY_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_LABEL;
#endif
	}
}

case 4006: /*ZEND_YIELD_SPEC_TMP_TMP_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 32: /*ZEND_ADD_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 57: /*ZEND_SUB_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 82: /*ZEND_MUL_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 107: /*ZEND_DIV_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 132: /*ZEND_MOD_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 157: /*ZEND_SL_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 182: /*ZEND_SR_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 207: /*ZEND_CONCAT_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 382: /*ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 407: /*ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 432: /*ZEND_IS_EQUAL_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 457: /*ZEND_IS_NOT_EQUAL_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 482: /*ZEND_IS_SMALLER_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 507: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 232: /*ZEND_BW_OR_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 257: /*ZEND_BW_AND_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 282: /*ZEND_BW_XOR_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 357: /*ZEND_BOOL_XOR_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_fetch_var_address_helper_SPEC_TMP_VAR:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_TMP_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		zval_dtor(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_TMP_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_TMP_VAR != IS_TMP_VAR) {
					zval_dtor(free_op1.var);
				}
				break;
			case ZEND_FETCH_LOCAL:
				zval_dtor(free_op1.var);
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_TMP_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2007: /*ZEND_FETCH_R_SPEC_TMP_VAR_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_TMP_VAR;
}

case 2082: /*ZEND_FETCH_W_SPEC_TMP_VAR_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_TMP_VAR;
}

case 2157: /*ZEND_FETCH_RW_SPEC_TMP_VAR_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_TMP_VAR;
}

case 2307: /*ZEND_FETCH_FUNC_ARG_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_TMP_VAR;
}

case 2382: /*ZEND_FETCH_UNSET_SPEC_TMP_VAR_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_TMP_VAR;
}

case 2232: /*ZEND_FETCH_IS_SPEC_TMP_VAR_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_TMP_VAR;
}

case 2032: /*ZEND_FETCH_DIM_R_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_TMP_VAR != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_TMP_VAR == IS_TMP_VAR || IS_TMP_VAR == IS_CONST) {
		zval *container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		zval_dtor(free_op1.var);
	} else {
		container = NULL;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1407: /*ZEND_ADD_VAR_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2807: /*ZEND_INIT_METHOD_CALL_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1207: /*ZEND_CASE_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	if (IS_TMP_VAR==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1807: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_TMP_VAR;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_TMP_VAR:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_TMP_VAR);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1782: /*ZEND_INIT_ARRAY_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_LABEL;
#endif
	}
}

case 1857: /*ZEND_UNSET_VAR_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2857: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_dtor(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 4007: /*ZEND_YIELD_SPEC_TMP_VAR_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

zend_fetch_var_address_helper_SPEC_TMP_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_TMP_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		zval_dtor(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_TMP_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_TMP_VAR != IS_TMP_VAR) {
					zval_dtor(free_op1.var);
				}
				break;
			case ZEND_FETCH_LOCAL:
				zval_dtor(free_op1.var);
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_TMP_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_TMP_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2008: /*ZEND_FETCH_R_SPEC_TMP_UNUSED_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_TMP_UNUSED;
}

case 2083: /*ZEND_FETCH_W_SPEC_TMP_UNUSED_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_TMP_UNUSED;
}

case 2158: /*ZEND_FETCH_RW_SPEC_TMP_UNUSED_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_TMP_UNUSED;
}

case 2308: /*ZEND_FETCH_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_TMP_UNUSED;
}

case 2383: /*ZEND_FETCH_UNSET_SPEC_TMP_UNUSED_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_TMP_UNUSED;
}

case 2233: /*ZEND_FETCH_IS_SPEC_TMP_UNUSED_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_TMP_UNUSED;
}

case 1808: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_TMP_UNUSED;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_TMP_UNUSED:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_UNUSED == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_TMP_UNUSED);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1783: /*ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_LABEL;
#endif
	}
}

case 1858: /*ZEND_UNSET_VAR_SPEC_TMP_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2858: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_TMP_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_dtor(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 4008: /*ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 34: /*ZEND_ADD_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 59: /*ZEND_SUB_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 84: /*ZEND_MUL_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 109: /*ZEND_DIV_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 134: /*ZEND_MOD_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 159: /*ZEND_SL_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 184: /*ZEND_SR_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 209: /*ZEND_CONCAT_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 384: /*ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 409: /*ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 434: /*ZEND_IS_EQUAL_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 459: /*ZEND_IS_NOT_EQUAL_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 484: /*ZEND_IS_SMALLER_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 509: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 234: /*ZEND_BW_OR_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 259: /*ZEND_BW_AND_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 284: /*ZEND_BW_XOR_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 359: /*ZEND_BOOL_XOR_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2034: /*ZEND_FETCH_DIM_R_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_TMP_VAR != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_TMP_VAR == IS_TMP_VAR || IS_TMP_VAR == IS_CONST) {
		zval *container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);

		zval_dtor(free_op1.var);
	} else {
		container = NULL;
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);


	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1409: /*ZEND_ADD_VAR_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE

	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2809: /*ZEND_INIT_METHOD_CALL_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1209: /*ZEND_CASE_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_TMP_VAR==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1809: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_TMP_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_TMP_CV;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_TMP_CV:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_TMP_CV);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1784: /*ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_LABEL;
#endif
	}
}

case 4009: /*ZEND_YIELD_SPEC_TMP_CV_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 310: /*ZEND_BW_NOT_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 335: /*ZEND_BOOL_NOT_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 860: /*ZEND_PRE_INC_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_increment_function(*var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 885: /*ZEND_PRE_DEC_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_decrement_function(*var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 910: /*ZEND_POST_INC_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		ZVAL_NULL(&EX_T(opline->result.var).tmp_var);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = &EX_T(opline->result.var).tmp_var;
	ZVAL_COPY_VALUE(retval, *var_ptr);
	zendi_zval_copy_ctor(*retval);

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_increment_function(*var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 935: /*ZEND_POST_DEC_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		ZVAL_NULL(&EX_T(opline->result.var).tmp_var);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = &EX_T(opline->result.var).tmp_var;
	ZVAL_COPY_VALUE(retval, *var_ptr);
	zendi_zval_copy_ctor(*retval);

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_decrement_function(*var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1010: /*ZEND_ECHO_SPEC_VAR_HANDLER*/ ZEND_ECHO_SPEC_VAR_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval z_copy;
	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) &&
	    Z_OBJ_HT_P(z)->get_method != NULL) {
	    if (IS_VAR == IS_TMP_VAR) {
	    	INIT_PZVAL(z);
	    }
		if (zend_std_cast_object_tostring(z, &z_copy, IS_STRING TSRMLS_CC) == SUCCESS) {
			zend_print_variable(&z_copy);
			zval_dtor(&z_copy);
		} else {
			zend_print_variable(z);
		}
	} else {
		zend_print_variable(z);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1035: /*ZEND_PRINT_SPEC_VAR_HANDLER*/
{
	USE_OPLINE

	ZVAL_LONG(&EX_T(opline->result.var).tmp_var, 1);
	goto ZEND_ECHO_SPEC_VAR_LABEL;
}

case 1085: /*ZEND_JMPZ_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

case 1110: /*ZEND_JMPNZ_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

case 1135: /*ZEND_JMPZNZ_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

case 1160: /*ZEND_JMPZ_EX_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1185: /*ZEND_JMPNZ_EX_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1760: /*ZEND_FREE_SPEC_VAR_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_VAR == IS_TMP_VAR) {
		zendi_zval_dtor(EX_T(opline->op1.var).tmp_var);
	} else {
		zval_ptr_dtor(&EX_T(opline->op1.var).var.ptr);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1560: /*ZEND_RETURN_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zval *retval_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();
	retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (!EG(return_value_ptr_ptr)) {
		if (IS_VAR == IS_TMP_VAR) {
			if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		}
	} else if (!0) { /* Not a temp var */
		if (*EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}
		if (IS_VAR == IS_CONST ||
		    (PZVAL_IS_REF(retval_ptr) && Z_REFCOUNT_P(retval_ptr) > 0)) {
			zval *ret;

			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, retval_ptr);
			zval_copy_ctor(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else if ((IS_VAR == IS_CV || IS_VAR == IS_VAR) &&
		           retval_ptr == &EG(uninitialized_zval)) {
			zval *ret;

			ALLOC_INIT_ZVAL(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else {
			*EG(return_value_ptr_ptr) = retval_ptr;
			Z_ADDREF_P(retval_ptr);
		}
	} else {
		zval *ret;

		if (*EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}

		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, retval_ptr);
		*EG(return_value_ptr_ptr) = ret;
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	goto zend_leave_helper_SPEC;
}

case 2785: /*ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zval *retval_ptr;
	zval **retval_ptr_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();

	do {
		if (EG(return_value_ptr_ptr) && *EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}

		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			if (!EG(return_value_ptr_ptr)) {
				if (IS_VAR == IS_TMP_VAR) {
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
				}
			} else if (!0) { /* Not a temp var */
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				zval_copy_ctor(ret);
				*EG(return_value_ptr_ptr) = ret;
			} else {
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				*EG(return_value_ptr_ptr) = ret;
			}
			break;
		}

		retval_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(retval_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_VAR == IS_VAR && !Z_ISREF_PP(retval_ptr_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    EX_T(opline->op1.var).var.fcall_returned_reference) {
			} else if (EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EG(return_value_ptr_ptr)) {
					retval_ptr = *retval_ptr_ptr;
					*EG(return_value_ptr_ptr) = retval_ptr;
					Z_ADDREF_P(retval_ptr);
				}
				break;
			}
		}

		if (EG(return_value_ptr_ptr)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr);
			Z_ADDREF_PP(retval_ptr_ptr);

			*EG(return_value_ptr_ptr) = *retval_ptr_ptr;
		}
	} while (0);

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	goto zend_leave_helper_SPEC;
}

case 2710: /*ZEND_THROW_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zval *value;
	zval *exception;
	zend_free_op free_op1;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}
	zend_exception_save(TSRMLS_C);
	/* Not sure if a complete copy is what we want here */
	ALLOC_ZVAL(exception);
	INIT_PZVAL_COPY(exception, value);
	if (!0) {
		zval_copy_ctor(exception);
	}

	zend_throw_exception_object(exception TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	HANDLE_EXCEPTION();
}

zend_send_by_var_helper_SPEC_VAR:
{
	USE_OPLINE
	zval *varptr;
	zend_free_op free_op1;
	varptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (varptr == &EG(uninitialized_zval)) {
		ALLOC_ZVAL(varptr);
		INIT_ZVAL(*varptr);
		Z_SET_REFCOUNT_P(varptr, 0);
	} else if (PZVAL_IS_REF(varptr)) {
		zval *original_var = varptr;

		ALLOC_ZVAL(varptr);
		ZVAL_COPY_VALUE(varptr, original_var);
		Z_UNSET_ISREF_P(varptr);
		Z_SET_REFCOUNT_P(varptr, 0);
		zval_copy_ctor(varptr);
	}
	Z_ADDREF_P(varptr);
	zend_vm_stack_push(varptr TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};  /* for string offsets */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2660: /*ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varptr;

	SAVE_OPLINE();
	if (opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) { /* Had function_ptr at compile_time */
		if (!(opline->extended_value & ZEND_ARG_SEND_BY_REF)) {
			goto zend_send_by_var_helper_SPEC_VAR;
		}
	} else if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
		goto zend_send_by_var_helper_SPEC_VAR;
	}

	if (IS_VAR == IS_VAR &&
		(opline->extended_value & ZEND_ARG_SEND_FUNCTION) &&
		EX_T(opline->op1.var).var.fcall_returned_reference &&
		EX_T(opline->op1.var).var.ptr) {
		varptr = EX_T(opline->op1.var).var.ptr;
		PZVAL_UNLOCK_EX(varptr, &free_op1, 0);
	} else {
		varptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	}
	if ((!(opline->extended_value & ZEND_ARG_SEND_FUNCTION) ||
	     EX_T(opline->op1.var).var.fcall_returned_reference) &&
	    varptr != &EG(uninitialized_zval) &&
	    (PZVAL_IS_REF(varptr) ||
	     (Z_REFCOUNT_P(varptr) == 1 && (IS_VAR == IS_CV || free_op1.var)))) {
		Z_SET_ISREF_P(varptr);
		Z_ADDREF_P(varptr);
		zend_vm_stack_push(varptr TSRMLS_CC);
	} else {
		zval *valptr;

		if ((opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) ?
			!(opline->extended_value & ZEND_ARG_SEND_SILENT) :
			!ARG_MAY_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
			zend_error(E_STRICT, "Only variables should be passed by reference");
		}
		ALLOC_ZVAL(valptr);
		INIT_PZVAL_COPY(valptr, varptr);
		if (!0) {
			zval_copy_ctor(valptr);
		}
		zend_vm_stack_push(valptr TSRMLS_CC);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1685: /*ZEND_SEND_REF_SPEC_VAR_HANDLER*/ ZEND_SEND_REF_SPEC_VAR_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **varptr_ptr;
	zval *varptr;

	SAVE_OPLINE();
	varptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(varptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Only variables can be passed by reference");
	}

	if (IS_VAR == IS_VAR && UNEXPECTED(*varptr_ptr == &EG(error_zval))) {
		ALLOC_INIT_ZVAL(varptr);
		zend_vm_stack_push(varptr TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION && !ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
		goto zend_send_by_var_helper_SPEC_VAR;
	}

	SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);
	varptr = *varptr_ptr;
	Z_ADDREF_P(varptr);
	zend_vm_stack_push(varptr TSRMLS_CC);

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1660: /*ZEND_SEND_VAR_SPEC_VAR_HANDLER*/
{
	USE_OPLINE

	if ((opline->extended_value == ZEND_DO_FCALL_BY_NAME)
		&& ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
		goto ZEND_SEND_REF_SPEC_VAR_LABEL;
	}
	SAVE_OPLINE();
	goto zend_send_by_var_helper_SPEC_VAR;
}

case 1310: /*ZEND_BOOL_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *retval = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC)));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1235: /*ZEND_SWITCH_FREE_SPEC_VAR_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	zval_ptr_dtor(&EX_T(opline->op1.var).var.ptr);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2760: /*ZEND_CLONE_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			AI_SET_PTR(&EX_T(opline->result.var), retval);
		}
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 535: /*ZEND_CAST_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!0) {
			zendi_zval_copy_ctor(*result);
		}
	}
	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (0) {
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!0) {
					zendi_zval_copy_ctor(*result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1835: /*ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;
	zend_free_op free_op1;
	zval *inc_filename;
	zval *tmp_inc_filename = NULL;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (inc_filename->type!=IS_STRING) {
		MAKE_STD_ZVAL(tmp_inc_filename);
		ZVAL_COPY_VALUE(tmp_inc_filename, inc_filename);
		zval_copy_ctor(tmp_inc_filename);
		convert_to_string(tmp_inc_filename);
		inc_filename = tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_exists(&EG(included_files), resolved_path, strlen(resolved_path)+1);
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==SUCCESS) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (tmp_inc_filename) {
		zval_ptr_dtor(&tmp_inc_filename);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			EX_T(opline->result.var).var.ptr = NULL;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			EG(return_value_ptr_ptr) = EX_T(opline->result.var).var.ptr_ptr;
		} else {
			EG(return_value_ptr_ptr) = NULL;
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		ZVAL_BOOL(retval, failure_retval);
		INIT_PZVAL(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1935: /*ZEND_FE_RESET_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *array_ptr, **array_ptr_ptr;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_VAR == IS_CV || IS_VAR == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {
			MAKE_STD_ZVAL(array_ptr);
			ZVAL_NULL(array_ptr);
		} else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_PP(array_ptr_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_PP(array_ptr_ptr);
			if (!ce || ce->get_iterator == NULL) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				Z_ADDREF_PP(array_ptr_ptr);
			}
			array_ptr = *array_ptr_ptr;
		} else {
			if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					Z_SET_ISREF_PP(array_ptr_ptr);
				}
			}
			array_ptr = *array_ptr_ptr;
			Z_ADDREF_P(array_ptr);
		}
	} else {
		array_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* IS_TMP_VAR */
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			array_ptr = tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ptr);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				Z_ADDREF_P(array_ptr);
			}
		} else if (IS_VAR == IS_CONST ||
		           ((IS_VAR == IS_CV || IS_VAR == IS_VAR) &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 1)) {
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			zval_copy_ctor(tmp);
			array_ptr = tmp;
		} else {
			Z_ADDREF_P(array_ptr);
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (iter && EXPECTED(EG(exception) == NULL)) {
			array_ptr = zend_iterator_wrap(iter TSRMLS_CC);
		} else {
			if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	EX_T(opline->result.var).fe.ptr = array_ptr;

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array_ptr);
				if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&array_ptr);
			if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = zend_objects_get_address(array_ptr TSRMLS_CC);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				char *str_key;
				uint str_key_len;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);
				if (key_type != HASH_KEY_NON_EXISTANT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key, str_key_len-1 TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, &EX_T(opline->result.var).fe.fe_pos);
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1960: /*ZEND_FE_FETCH_SPEC_VAR_HANDLER*/
{
	USE_OPLINE

	zval *array = EX_T(opline->op1.var).fe.ptr;
	zval **value;
	char *str_key;
	uint str_key_len;
	ulong int_key;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	int key_type = 0;
	zend_bool use_key = (zend_bool)(opline->extended_value & ZEND_FE_FETCH_WITH_KEY);

	SAVE_OPLINE();

	switch (zend_iterator_unwrap(array, &iter TSRMLS_CC)) {
		default:
		case ZEND_ITER_INVALID:
			zend_error(E_WARNING, "Invalid argument supplied for foreach()");
			ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);

		case ZEND_ITER_PLAIN_OBJECT: {
			const char *class_name, *prop_name;
			zend_object *zobj = zend_objects_get_address(array TSRMLS_CC);

			fe_ht = Z_OBJPROP_P(array);
			zend_hash_set_pointer(fe_ht, &EX_T(opline->op1.var).fe.fe_pos);
			do {
				if (zend_hash_get_current_data(fe_ht, (void **) &value)==FAILURE) {
					/* reached end of iteration */
					ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
				}
				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);

				zend_hash_move_forward(fe_ht);
			} while (key_type == HASH_KEY_NON_EXISTANT ||
			         (key_type != HASH_KEY_IS_LONG &&
			          zend_check_property_access(zobj, str_key, str_key_len-1 TSRMLS_CC) != SUCCESS));
			zend_hash_get_pointer(fe_ht, &EX_T(opline->op1.var).fe.fe_pos);
			if (use_key && key_type != HASH_KEY_IS_LONG) {
				zend_unmangle_property_name(str_key, str_key_len-1, &class_name, &prop_name);
				str_key_len = strlen(prop_name);
				str_key = estrndup(prop_name, str_key_len);
				str_key_len++;
			}
			break;
		}

		case ZEND_ITER_PLAIN_ARRAY:
			fe_ht = Z_ARRVAL_P(array);
			zend_hash_set_pointer(fe_ht, &EX_T(opline->op1.var).fe.fe_pos);
			if (zend_hash_get_current_data(fe_ht, (void **) &value)==FAILURE) {
				/* reached end of iteration */
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}
			if (use_key) {
				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 1, NULL);
			}
			zend_hash_move_forward(fe_ht);
			zend_hash_get_pointer(fe_ht, &EX_T(opline->op1.var).fe.fe_pos);
			break;

		case ZEND_ITER_OBJECT:
			/* !iter happens from exception */
			if (iter && ++iter->index > 0) {
				/* This could cause an endless loop if index becomes zero again.
				 * In case that ever happens we need an additional flag. */
				iter->funcs->move_forward(iter TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor(&array);
					HANDLE_EXCEPTION();
				}
			}
			/* If index is zero we come from FE_RESET and checked valid() already. */
			if (!iter || (iter->index > 0 && iter->funcs->valid(iter TSRMLS_CC) == FAILURE)) {
				/* reached end of iteration */
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor(&array);
					HANDLE_EXCEPTION();
				}
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}
			iter->funcs->get_current_data(iter, &value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array);
				HANDLE_EXCEPTION();
			}
			if (!value) {
				/* failure in get_current_data */
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}
			if (use_key) {
				if (iter->funcs->get_current_key) {
					key_type = iter->funcs->get_current_key(iter, &str_key, &str_key_len, &int_key TSRMLS_CC);
					if (UNEXPECTED(EG(exception) != NULL)) {
						zval_ptr_dtor(&array);
						HANDLE_EXCEPTION();
					}
				} else {
					key_type = HASH_KEY_IS_LONG;
					int_key = iter->index;
				}
			}
			break;
	}

	if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
		SEPARATE_ZVAL_IF_NOT_REF(value);
		Z_SET_ISREF_PP(value);
		EX_T(opline->result.var).var.ptr_ptr = value;
		Z_ADDREF_PP(value);
	} else {
		PZVAL_LOCK(*value);
		AI_SET_PTR(&EX_T(opline->result.var), *value);
	}

	if (use_key) {
		zval *key = &EX_T((opline+1)->result.var).tmp_var;

		switch (key_type) {
			case HASH_KEY_IS_STRING:
				Z_STRVAL_P(key) = (char*)str_key;
				Z_STRLEN_P(key) = str_key_len-1;
				Z_TYPE_P(key) = IS_STRING;
				break;
			case HASH_KEY_IS_LONG:
				Z_LVAL_P(key) = int_key;
				Z_TYPE_P(key) = IS_LONG;
				break;
			default:
			case HASH_KEY_NON_EXISTANT:
				ZVAL_NULL(key);
				break;
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 1985: /*ZEND_EXIT_SPEC_VAR_HANDLER*/
{
#if 0 || (IS_VAR != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;
		zval *ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

case 3810: /*ZEND_JMP_SET_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value)) {
		ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
		if (!0) {
			zendi_zval_copy_ctor(EX_T(opline->result.var).tmp_var);
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3960: /*ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value)) {
		if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
			Z_ADDREF_P(value);
			EX_T(opline->result.var).var.ptr = value;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		} else {
			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, value);
			EX_T(opline->result.var).var.ptr = ret;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			if (!0) {
				zval_copy_ctor(EX_T(opline->result.var).var.ptr);
			}
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 560: /*ZEND_QM_ASSIGN_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
	if (!0) {
		zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3935: /*ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		Z_ADDREF_P(value);
		EX_T(opline->result.var).var.ptr = value;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	} else {
		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, value);
		EX_T(opline->result.var).var.ptr = ret;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		if (!0) {
			zval_copy_ctor(EX_T(opline->result.var).var.ptr);
		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3460: /*ZEND_INSTANCEOF_SPEC_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (Z_TYPE_P(expr) == IS_OBJECT && Z_OBJ_HT_P(expr)->get_class_entry) {
		result = instanceof_function(Z_OBJCE_P(expr), EX_T(opline->op2.var).class_entry TSRMLS_CC);
	} else {
		result = 0;
	}
	ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, result);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 35: /*ZEND_ADD_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 60: /*ZEND_SUB_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 85: /*ZEND_MUL_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 110: /*ZEND_DIV_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 135: /*ZEND_MOD_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 160: /*ZEND_SL_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 185: /*ZEND_SR_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 210: /*ZEND_CONCAT_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 385: /*ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 410: /*ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 435: /*ZEND_IS_EQUAL_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 460: /*ZEND_IS_NOT_EQUAL_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 485: /*ZEND_IS_SMALLER_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 510: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 235: /*ZEND_BW_OR_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 260: /*ZEND_BW_AND_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 285: /*ZEND_BW_XOR_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 360: /*ZEND_BOOL_XOR_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_obj_helper_SPEC_VAR_CONST:
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = opline->op2.zv;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_VAR_CONST:
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_CONST;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_CONST;
				} else {
					zval *dim = opline->op2.zv;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CONST, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = opline->op2.zv;
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}

		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 585: /*ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 610: /*ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 635: /*ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 660: /*ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 685: /*ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 710: /*ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 735: /*ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 760: /*ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 785: /*ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 810: /*ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

case 835: /*ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_VAR_CONST;
}

zend_pre_incdec_property_helper_SPEC_VAR_CONST:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3310: /*ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_VAR_CONST;
}

case 3335: /*ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_VAR_CONST;
}

zend_post_incdec_property_helper_SPEC_VAR_CONST:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3360: /*ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_VAR_CONST;
}

case 3385: /*ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_VAR_CONST;
}

zend_fetch_var_address_helper_SPEC_VAR_CONST:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_VAR != IS_TMP_VAR) {
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
				}
				break;
			case ZEND_FETCH_LOCAL:
				if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2010: /*ZEND_FETCH_R_SPEC_VAR_CONST_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_VAR_CONST;
}

case 2085: /*ZEND_FETCH_W_SPEC_VAR_CONST_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_VAR_CONST;
}

case 2160: /*ZEND_FETCH_RW_SPEC_VAR_CONST_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_VAR_CONST;
}

case 2310: /*ZEND_FETCH_FUNC_ARG_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_VAR_CONST;
}

case 2385: /*ZEND_FETCH_UNSET_SPEC_VAR_CONST_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_VAR_CONST;
}

case 2235: /*ZEND_FETCH_IS_SPEC_VAR_CONST_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_VAR_CONST;
}

case 2035: /*ZEND_FETCH_DIM_R_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_VAR != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_VAR == IS_TMP_VAR || IS_VAR == IS_CONST) {
		zval *container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2110: /*ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_W TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2185: /*ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_RW TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2260: /*ZEND_FETCH_DIM_IS_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_IS TSRMLS_CC);

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2335: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_CONST == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2410: /*ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_UNSET TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

zend_fetch_property_address_read_helper_SPEC_VAR_CONST:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2060: /*ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_VAR_CONST;
}

case 2135: /*ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;

	if (IS_VAR == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2210: /*ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2285: /*ZEND_FETCH_OBJ_IS_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2360: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = opline->op2.zv;
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_VAR_CONST;
	}
}

case 2435: /*ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = opline->op2.zv;

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3410: /*ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = opline->op2.zv;

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 3685: /*ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = opline->op2.zv;

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = opline->op2.zv;
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_CONST, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 960: /*ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER*/ ZEND_ASSIGN_SPEC_VAR_CONST_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = opline->op2.zv;
	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_CONST TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				AI_SET_PTR(&EX_T(opline->result.var), retval);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else if (IS_VAR == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else {
		if (IS_CONST == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_CONST == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			AI_SET_PTR(&EX_T(opline->result.var), value);
		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2810: /*ZEND_INIT_METHOD_CALL_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2835: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_CONST != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_CONST == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = opline->op2.zv;

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1210: /*ZEND_CASE_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_VAR==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 opline->op2.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2485: /*ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_VAR == IS_UNUSED) {
		zend_constant *c;
		zval *retval;

		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			c = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if ((c = zend_quick_get_constant(opline->op2.literal + 1, opline->extended_value TSRMLS_CC)) == NULL) {
			if ((opline->extended_value & IS_CONSTANT_UNQUALIFIED) != 0) {
				char *actual = (char *)zend_memrchr(Z_STRVAL_P(opline->op2.zv), '\\', Z_STRLEN_P(opline->op2.zv));
				if(!actual) {
					actual = Z_STRVAL_P(opline->op2.zv);
				} else {
					actual++;
				}
				/* non-qualified constant - allow text substitution */
				zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'", actual, actual);
				ZVAL_STRINGL(&EX_T(opline->result.var).tmp_var, actual, Z_STRLEN_P(opline->op2.zv)-(actual - Z_STRVAL_P(opline->op2.zv)), 1);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else {
				zend_error_noreturn(E_ERROR, "Undefined constant '%s'", Z_STRVAL_P(opline->op2.zv));
			}
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, c);
		}
		retval = &EX_T(opline->result.var).tmp_var;
		ZVAL_COPY_VALUE(retval, &c->value);
		zval_copy_ctor(retval);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		/* class constant */
		zend_class_entry *ce;
		zval **value;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				value = CACHED_PTR(opline->op2.literal->cache_slot);
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else if (CACHED_PTR(opline->op1.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op1.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op1.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op1.var).class_entry;
			if ((value = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce)) != NULL) {
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
		}

		if (EXPECTED(zend_hash_quick_find(&ce->constants_table, Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv)+1, Z_HASH_P(opline->op2.zv), (void **) &value) == SUCCESS)) {
			if (Z_TYPE_PP(value) == IS_CONSTANT_ARRAY ||
			    (Z_TYPE_PP(value) & IS_CONSTANT_TYPE_MASK) == IS_CONSTANT) {
				zend_class_entry *old_scope = EG(scope);

				EG(scope) = ce;
				zval_update_constant(value, (void *) 1 TSRMLS_CC);
				EG(scope) = old_scope;
			}
			if (IS_VAR == IS_CONST) {
				CACHE_PTR(opline->op2.literal->cache_slot, value);
			} else {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, value);
			}
			ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
			zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
		} else {
			zend_error_noreturn(E_ERROR, "Undefined class constant '%s'", Z_STRVAL_P(opline->op2.zv));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1810: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_VAR_CONST;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_VAR_CONST:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_VAR_CONST);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1785: /*ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_LABEL;
#endif
	}
}

case 1860: /*ZEND_UNSET_VAR_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1885: /*ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = opline->op2.zv;

	if (IS_VAR != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CONST == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_VAR_CONST);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_VAR_CONST:
						zend_hash_index_del(ht, hval);
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1910: /*ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = opline->op2.zv;

	if (IS_VAR != IS_VAR || container) {
		if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2860: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	offset = opline->op2.zv;

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_VAR_CONST;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_VAR_CONST:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_VAR_CONST);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2885: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CONST_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST;
}

case 3710: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CONST_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST;
}

case 4010: /*ZEND_YIELD_SPEC_VAR_CONST_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

			if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 36: /*ZEND_ADD_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 61: /*ZEND_SUB_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 86: /*ZEND_MUL_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 111: /*ZEND_DIV_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 136: /*ZEND_MOD_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 161: /*ZEND_SL_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 186: /*ZEND_SR_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 211: /*ZEND_CONCAT_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 386: /*ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 411: /*ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 436: /*ZEND_IS_EQUAL_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 461: /*ZEND_IS_NOT_EQUAL_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 486: /*ZEND_IS_SMALLER_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 511: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 236: /*ZEND_BW_OR_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 261: /*ZEND_BW_AND_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 286: /*ZEND_BW_XOR_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 361: /*ZEND_BOOL_XOR_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_obj_helper_SPEC_VAR_TMP:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_VAR_TMP:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_TMP;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_TMP;
				} else {
					zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
		zval_dtor(free_op2.var);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}
	zval_dtor(free_op2.var);

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 586: /*ZEND_ASSIGN_ADD_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 611: /*ZEND_ASSIGN_SUB_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 636: /*ZEND_ASSIGN_MUL_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 661: /*ZEND_ASSIGN_DIV_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 686: /*ZEND_ASSIGN_MOD_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 711: /*ZEND_ASSIGN_SL_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 736: /*ZEND_ASSIGN_SR_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 761: /*ZEND_ASSIGN_CONCAT_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 786: /*ZEND_ASSIGN_BW_OR_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 811: /*ZEND_ASSIGN_BW_AND_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

case 836: /*ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMP_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_VAR_TMP;
}

zend_pre_incdec_property_helper_SPEC_VAR_TMP:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3311: /*ZEND_PRE_INC_OBJ_SPEC_VAR_TMP_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_VAR_TMP;
}

case 3336: /*ZEND_PRE_DEC_OBJ_SPEC_VAR_TMP_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_VAR_TMP;
}

zend_post_incdec_property_helper_SPEC_VAR_TMP:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3361: /*ZEND_POST_INC_OBJ_SPEC_VAR_TMP_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_VAR_TMP;
}

case 3386: /*ZEND_POST_DEC_OBJ_SPEC_VAR_TMP_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_VAR_TMP;
}

case 2036: /*ZEND_FETCH_DIM_R_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_VAR != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_VAR == IS_TMP_VAR || IS_VAR == IS_CONST) {
		zval *container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2111: /*ZEND_FETCH_DIM_W_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2186: /*ZEND_FETCH_DIM_RW_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2261: /*ZEND_FETCH_DIM_IS_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_IS TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2336: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_TMP_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
	}
	zval_dtor(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2411: /*ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_UNSET TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

zend_fetch_property_address_read_helper_SPEC_VAR_TMP:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2061: /*ZEND_FETCH_OBJ_R_SPEC_VAR_TMP_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_VAR_TMP;
}

case 2136: /*ZEND_FETCH_OBJ_W_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2211: /*ZEND_FETCH_OBJ_RW_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2286: /*ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2361: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_VAR_TMP;
	}
}

case 2436: /*ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3411: /*ZEND_ASSIGN_OBJ_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property_name);
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 3686: /*ZEND_ASSIGN_DIM_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property_name);
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
		zval_dtor(free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 961: /*ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER*/ ZEND_ASSIGN_SPEC_VAR_TMP_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_TMP_VAR TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				AI_SET_PTR(&EX_T(opline->result.var), retval);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else if (IS_VAR == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (1) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else {
		if (IS_TMP_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_TMP_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			AI_SET_PTR(&EX_T(opline->result.var), value);
		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2811: /*ZEND_INIT_METHOD_CALL_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2836: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_TMP_VAR == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_TMP_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_TMP_VAR != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;
		zend_free_op free_op2;

		if (IS_TMP_VAR == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_TMP_VAR != IS_CONST) {
			zval_dtor(free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1211: /*ZEND_CASE_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	if (IS_VAR==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1811: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_VAR_TMP;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_VAR_TMP:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_VAR_TMP);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1786: /*ZEND_INIT_ARRAY_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_LABEL;
#endif
	}
}

case 1886: /*ZEND_UNSET_DIM_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_TMP_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_VAR_TMP);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_VAR_TMP:
						zend_hash_index_del(ht, hval);
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				zval_dtor(free_op2.var);
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (1) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (1) {
					zval_ptr_dtor(&offset);
				} else {
					zval_dtor(free_op2.var);
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				zval_dtor(free_op2.var);
				break;
		}
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1911: /*ZEND_UNSET_OBJ_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (1) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (1) {
				zval_ptr_dtor(&offset);
			} else {
				zval_dtor(free_op2.var);
			}
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zval_dtor(free_op2.var);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_VAR_TMP;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_VAR_TMP:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_VAR_TMP);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		zval_dtor(free_op2.var);
	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		zval_dtor(free_op2.var);
	} else {
		zval_dtor(free_op2.var);
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2886: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_TMP_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP;
}

case 3711: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_TMP_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP;
}

case 4011: /*ZEND_YIELD_SPEC_VAR_TMP_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

			if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 37: /*ZEND_ADD_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 62: /*ZEND_SUB_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 87: /*ZEND_MUL_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 112: /*ZEND_DIV_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 137: /*ZEND_MOD_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 162: /*ZEND_SL_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 187: /*ZEND_SR_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 212: /*ZEND_CONCAT_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 387: /*ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 412: /*ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 437: /*ZEND_IS_EQUAL_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 462: /*ZEND_IS_NOT_EQUAL_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 487: /*ZEND_IS_SMALLER_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 512: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 237: /*ZEND_BW_OR_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 262: /*ZEND_BW_AND_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 287: /*ZEND_BW_XOR_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 362: /*ZEND_BOOL_XOR_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_obj_helper_SPEC_VAR_VAR:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_VAR_VAR:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_VAR;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_VAR;
				} else {
					zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 587: /*ZEND_ASSIGN_ADD_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 612: /*ZEND_ASSIGN_SUB_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 637: /*ZEND_ASSIGN_MUL_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 662: /*ZEND_ASSIGN_DIV_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 687: /*ZEND_ASSIGN_MOD_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 712: /*ZEND_ASSIGN_SL_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 737: /*ZEND_ASSIGN_SR_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 762: /*ZEND_ASSIGN_CONCAT_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 787: /*ZEND_ASSIGN_BW_OR_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 812: /*ZEND_ASSIGN_BW_AND_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

case 837: /*ZEND_ASSIGN_BW_XOR_SPEC_VAR_VAR_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_VAR_VAR;
}

zend_pre_incdec_property_helper_SPEC_VAR_VAR:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3312: /*ZEND_PRE_INC_OBJ_SPEC_VAR_VAR_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_VAR_VAR;
}

case 3337: /*ZEND_PRE_DEC_OBJ_SPEC_VAR_VAR_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_VAR_VAR;
}

zend_post_incdec_property_helper_SPEC_VAR_VAR:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3362: /*ZEND_POST_INC_OBJ_SPEC_VAR_VAR_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_VAR_VAR;
}

case 3387: /*ZEND_POST_DEC_OBJ_SPEC_VAR_VAR_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_VAR_VAR;
}

zend_fetch_var_address_helper_SPEC_VAR_VAR:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_VAR != IS_TMP_VAR) {
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
				}
				break;
			case ZEND_FETCH_LOCAL:
				if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2012: /*ZEND_FETCH_R_SPEC_VAR_VAR_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_VAR_VAR;
}

case 2087: /*ZEND_FETCH_W_SPEC_VAR_VAR_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_VAR_VAR;
}

case 2162: /*ZEND_FETCH_RW_SPEC_VAR_VAR_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_VAR_VAR;
}

case 2312: /*ZEND_FETCH_FUNC_ARG_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_VAR_VAR;
}

case 2387: /*ZEND_FETCH_UNSET_SPEC_VAR_VAR_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_VAR_VAR;
}

case 2237: /*ZEND_FETCH_IS_SPEC_VAR_VAR_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_VAR_VAR;
}

case 2037: /*ZEND_FETCH_DIM_R_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_VAR != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_VAR == IS_TMP_VAR || IS_VAR == IS_CONST) {
		zval *container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2112: /*ZEND_FETCH_DIM_W_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_W TSRMLS_CC);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2187: /*ZEND_FETCH_DIM_RW_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_RW TSRMLS_CC);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2262: /*ZEND_FETCH_DIM_IS_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_IS TSRMLS_CC);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2337: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
	}
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2412: /*ZEND_FETCH_DIM_UNSET_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_UNSET TSRMLS_CC);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

zend_fetch_property_address_read_helper_SPEC_VAR_VAR:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2062: /*ZEND_FETCH_OBJ_R_SPEC_VAR_VAR_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_VAR_VAR;
}

case 2137: /*ZEND_FETCH_OBJ_W_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2212: /*ZEND_FETCH_OBJ_RW_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2287: /*ZEND_FETCH_OBJ_IS_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2362: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_VAR_VAR;
	}
}

case 2437: /*ZEND_FETCH_OBJ_UNSET_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3412: /*ZEND_ASSIGN_OBJ_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 3687: /*ZEND_ASSIGN_DIM_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_VAR, BP_VAR_W TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 962: /*ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER*/ ZEND_ASSIGN_SPEC_VAR_VAR_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_VAR TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				AI_SET_PTR(&EX_T(opline->result.var), retval);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else if (IS_VAR == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else {
		if (IS_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			AI_SET_PTR(&EX_T(opline->result.var), value);
		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* zend_assign_to_variable() always takes care of op2, never free it! */
 	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 987: /*ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **variable_ptr_ptr;
	zval **value_ptr_ptr;

	SAVE_OPLINE();
	value_ptr_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR &&
	    value_ptr_ptr &&
	    !Z_ISREF_PP(value_ptr_ptr) &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !EX_T(opline->op2.var).var.fcall_returned_reference) {
		if (free_op2.var == NULL) {
			PZVAL_LOCK(*value_ptr_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
			HANDLE_EXCEPTION();
		}
		goto ZEND_ASSIGN_SPEC_VAR_VAR_LABEL;
	} else if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		PZVAL_LOCK(*value_ptr_ptr);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr)) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}

	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if ((IS_VAR == IS_VAR && UNEXPECTED(value_ptr_ptr == NULL)) ||
	    (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr TSRMLS_CC);

	if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		Z_DELREF_PP(variable_ptr_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*variable_ptr_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *variable_ptr_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2812: /*ZEND_INIT_METHOD_CALL_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2837: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_VAR == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_VAR != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;
		zend_free_op free_op2;

		if (IS_VAR == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_VAR != IS_CONST) {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1212: /*ZEND_CASE_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	if (IS_VAR==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1812: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_VAR_VAR;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_VAR_VAR:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_VAR_VAR);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1787: /*ZEND_INIT_ARRAY_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_LABEL;
#endif
	}
}

case 1862: /*ZEND_UNSET_VAR_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1887: /*ZEND_UNSET_DIM_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_VAR_VAR);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_VAR_VAR:
						zend_hash_index_del(ht, hval);
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {
					if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
				break;
		}
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1912: /*ZEND_UNSET_OBJ_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
			}
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2862: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR:
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_VAR_VAR;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_VAR_VAR:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_VAR_VAR);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2887: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_VAR_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR;
}

case 3712: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_VAR_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR;
}

case 4012: /*ZEND_YIELD_SPEC_VAR_VAR_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

			if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = NULL;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_VAR_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED;
				} else {
					zval *dim = NULL;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_UNUSED, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = NULL;
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}

		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 588: /*ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 613: /*ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 638: /*ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 663: /*ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 688: /*ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 713: /*ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 738: /*ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 763: /*ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 788: /*ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 813: /*ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

case 838: /*ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_VAR_UNUSED;
}

zend_fetch_var_address_helper_SPEC_VAR_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

 	if (IS_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_VAR == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_VAR != IS_TMP_VAR) {
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
				}
				break;
			case ZEND_FETCH_LOCAL:
				if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_VAR == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_VAR != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2013: /*ZEND_FETCH_R_SPEC_VAR_UNUSED_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_VAR_UNUSED;
}

case 2088: /*ZEND_FETCH_W_SPEC_VAR_UNUSED_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_VAR_UNUSED;
}

case 2163: /*ZEND_FETCH_RW_SPEC_VAR_UNUSED_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_VAR_UNUSED;
}

case 2313: /*ZEND_FETCH_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_VAR_UNUSED;
}

case 2388: /*ZEND_FETCH_UNSET_SPEC_VAR_UNUSED_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_VAR_UNUSED;
}

case 2238: /*ZEND_FETCH_IS_SPEC_VAR_UNUSED_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_VAR_UNUSED;
}

case 2113: /*ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_W TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2188: /*ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_RW TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2338: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_R TSRMLS_CC);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3688: /*ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = NULL;

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = NULL;
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_UNUSED, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 2838: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_UNUSED != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_UNUSED == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = NULL;

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_UNUSED == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_UNUSED == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1813: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_VAR_UNUSED;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_VAR_UNUSED:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_UNUSED == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_VAR_UNUSED);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1788: /*ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_LABEL;
#endif
	}
}

case 1863: /*ZEND_UNSET_VAR_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
						zval_ptr_dtor(&varname);
					}
					if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_VAR != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		zval_ptr_dtor(&varname);
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2863: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_VAR == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3913: /*ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval *var_ptr, *new_zv;

	SAVE_OPLINE();
	var_ptr = EX_T(opline->op1.var).var.ptr;
	if (Z_TYPE_P(var_ptr) != IS_OBJECT &&
			!PZVAL_IS_REF(var_ptr) &&
			Z_REFCOUNT_P(var_ptr) > 1) {

		Z_DELREF_P(var_ptr);
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, var_ptr);
		var_ptr = new_zv;
		zval_copy_ctor(var_ptr);
		EX_T(opline->op1.var).var.ptr = var_ptr;
	}
	ZEND_VM_NEXT_OPCODE();
}

case 4013: /*ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

			if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 39: /*ZEND_ADD_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 64: /*ZEND_SUB_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 89: /*ZEND_MUL_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 114: /*ZEND_DIV_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 139: /*ZEND_MOD_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 164: /*ZEND_SL_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 189: /*ZEND_SR_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 214: /*ZEND_CONCAT_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 389: /*ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 414: /*ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 439: /*ZEND_IS_EQUAL_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 464: /*ZEND_IS_NOT_EQUAL_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 489: /*ZEND_IS_SMALLER_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 514: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 239: /*ZEND_BW_OR_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 264: /*ZEND_BW_AND_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 289: /*ZEND_BW_XOR_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 364: /*ZEND_BOOL_XOR_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_obj_helper_SPEC_VAR_CV:
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_VAR_CV:
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_CV;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_VAR_CV;
				} else {
					zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CV, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}

		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 589: /*ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 614: /*ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 639: /*ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 664: /*ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 689: /*ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 714: /*ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 739: /*ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 764: /*ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 789: /*ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 814: /*ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

case 839: /*ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_VAR_CV;
}

zend_pre_incdec_property_helper_SPEC_VAR_CV:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3314: /*ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_VAR_CV;
}

case 3339: /*ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_VAR_CV;
}

zend_post_incdec_property_helper_SPEC_VAR_CV:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3364: /*ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_VAR_CV;
}

case 3389: /*ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_VAR_CV;
}

case 2039: /*ZEND_FETCH_DIM_R_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_VAR != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_VAR == IS_TMP_VAR || IS_VAR == IS_CONST) {
		zval *container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);

		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);

		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2114: /*ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_W TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2189: /*ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_RW TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2264: /*ZEND_FETCH_DIM_IS_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_IS TSRMLS_CC);

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2339: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_W TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_CV == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2414: /*ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_UNSET TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

zend_fetch_property_address_read_helper_SPEC_VAR_CV:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2064: /*ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_VAR_CV;
}

case 2139: /*ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2214: /*ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2289: /*ZEND_FETCH_OBJ_IS_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2364: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_VAR_CV;
	}
}

case 2439: /*ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3414: /*ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 3689: /*ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_CV, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 964: /*ZEND_ASSIGN_SPEC_VAR_CV_HANDLER*/ ZEND_ASSIGN_SPEC_VAR_CV_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_CV TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				AI_SET_PTR(&EX_T(opline->result.var), retval);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else if (IS_VAR == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else {
		if (IS_CV == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_CV == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			AI_SET_PTR(&EX_T(opline->result.var), value);
		}
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 989: /*ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **variable_ptr_ptr;
	zval **value_ptr_ptr;

	SAVE_OPLINE();
	value_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_VAR &&
	    value_ptr_ptr &&
	    !Z_ISREF_PP(value_ptr_ptr) &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !EX_T(opline->op2.var).var.fcall_returned_reference) {
		if (free_op2.var == NULL) {
			PZVAL_LOCK(*value_ptr_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		goto ZEND_ASSIGN_SPEC_VAR_CV_LABEL;
	} else if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		PZVAL_LOCK(*value_ptr_ptr);
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr)) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}

	variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if ((IS_CV == IS_VAR && UNEXPECTED(value_ptr_ptr == NULL)) ||
	    (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr TSRMLS_CC);

	if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		Z_DELREF_PP(variable_ptr_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*variable_ptr_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *variable_ptr_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2814: /*ZEND_INIT_METHOD_CALL_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2839: /*ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(opline->op1.literal->cache_slot)) {
			ce = CACHED_PTR(opline->op1.literal->cache_slot);
		} else {
			ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(ce == NULL)) {
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
			CACHE_PTR(opline->op1.literal->cache_slot, ce);
		}
		call->called_scope = ce;
	} else {
		ce = EX_T(opline->op1.var).class_entry;

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_CV == IS_CONST &&
	    CACHED_PTR(opline->op2.literal->cache_slot)) {
		call->fbc = CACHED_PTR(opline->op2.literal->cache_slot);
	} else if (IS_VAR != IS_CONST &&
	           IS_CV == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce))) {
		/* do nothing */
	} else if (IS_CV != IS_UNUSED) {
		char *function_name_strval = NULL;
		int function_name_strlen = 0;


		if (IS_CV == IS_CONST) {
			function_name_strval = Z_STRVAL_P(opline->op2.zv);
			function_name_strlen = Z_STRLEN_P(opline->op2.zv);
		} else {
			function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				zend_error_noreturn(E_ERROR, "Function name must be a string");
			} else {
				function_name_strval = Z_STRVAL_P(function_name);
				function_name_strlen = Z_STRLEN_P(function_name);
 			}
		}

		if (function_name_strval) {
			if (ce->get_static_method) {
				call->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);
			} else {
				call->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			}
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name, function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
				if (IS_VAR == IS_CONST) {
					CACHE_PTR(opline->op2.literal->cache_slot, call->fbc);
				} else {
					CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, call->fbc);
				}
			}
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (EG(This) && Z_OBJCE_P(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (EG(This) &&
		    Z_OBJ_HT_P(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE_P(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name, call->fbc->common.function_name);
			}
		}
		if ((call->object = EG(This))) {
			Z_ADDREF_P(call->object);
			call->called_scope = Z_OBJCE_P(call->object);
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1214: /*ZEND_CASE_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	if (IS_VAR==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1814: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_LABEL:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_VAR == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_VAR_CV;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_VAR_CV:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_VAR_CV);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	} else {
		if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1789: /*ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_LABEL;
#endif
	}
}

case 1889: /*ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CV == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_VAR_CV);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_VAR_CV:
						zend_hash_index_del(ht, hval);
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1914: /*ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR != IS_VAR || container) {
		if (IS_VAR == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}
	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_VAR_CV;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_VAR_CV:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_VAR_CV);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2889: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CV_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV;
}

case 3714: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CV_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV;
}

case 4014: /*ZEND_YIELD_SPEC_VAR_CV_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

				if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

			if (free_op1.var) {zval_ptr_dtor(&free_op1.var);};
		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 2765: /*ZEND_CLONE_SPEC_UNUSED_HANDLER*/
{
	USE_OPLINE

	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (IS_UNUSED == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			AI_SET_PTR(&EX_T(opline->result.var), retval);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1990: /*ZEND_EXIT_SPEC_UNUSED_HANDLER*/
{
#if 0 || (IS_UNUSED != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_UNUSED != IS_UNUSED) {

		zval *ptr = NULL;

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}

	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST:
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = opline->op2.zv;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_UNUSED_CONST:
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST;
				} else {
					zval *dim = opline->op2.zv;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CONST, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = opline->op2.zv;
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 590: /*ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 615: /*ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 640: /*ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 665: /*ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 690: /*ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 715: /*ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 740: /*ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 765: /*ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 790: /*ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 815: /*ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

case 840: /*ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CONST;
}

zend_pre_incdec_property_helper_SPEC_UNUSED_CONST:
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3315: /*ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_UNUSED_CONST;
}

case 3340: /*ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_UNUSED_CONST;
}

zend_post_incdec_property_helper_SPEC_UNUSED_CONST:
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3365: /*ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_UNUSED_CONST;
}

case 3390: /*ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_UNUSED_CONST;
}

zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST:
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2065: /*ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST;
}

case 2140: /*ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;

	if (IS_UNUSED == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2215: /*ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2290: /*ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2365: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = opline->op2.zv;
		container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST;
	}
}

case 2440: /*ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = opline->op2.zv;

	if (IS_UNUSED == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3415: /*ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE

	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property_name = opline->op2.zv;

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 1365: /*ZEND_ADD_CHAR_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE
	zval *str = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_char_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_char_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

case 1390: /*ZEND_ADD_STRING_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE
	zval *str = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	add_string_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

case 2815: /*ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;

	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2490: /*ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_UNUSED == IS_UNUSED) {
		zend_constant *c;
		zval *retval;

		if (CACHED_PTR(opline->op2.literal->cache_slot)) {
			c = CACHED_PTR(opline->op2.literal->cache_slot);
		} else if ((c = zend_quick_get_constant(opline->op2.literal + 1, opline->extended_value TSRMLS_CC)) == NULL) {
			if ((opline->extended_value & IS_CONSTANT_UNQUALIFIED) != 0) {
				char *actual = (char *)zend_memrchr(Z_STRVAL_P(opline->op2.zv), '\\', Z_STRLEN_P(opline->op2.zv));
				if(!actual) {
					actual = Z_STRVAL_P(opline->op2.zv);
				} else {
					actual++;
				}
				/* non-qualified constant - allow text substitution */
				zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'", actual, actual);
				ZVAL_STRINGL(&EX_T(opline->result.var).tmp_var, actual, Z_STRLEN_P(opline->op2.zv)-(actual - Z_STRVAL_P(opline->op2.zv)), 1);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else {
				zend_error_noreturn(E_ERROR, "Undefined constant '%s'", Z_STRVAL_P(opline->op2.zv));
			}
		} else {
			CACHE_PTR(opline->op2.literal->cache_slot, c);
		}
		retval = &EX_T(opline->result.var).tmp_var;
		ZVAL_COPY_VALUE(retval, &c->value);
		zval_copy_ctor(retval);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		/* class constant */
		zend_class_entry *ce;
		zval **value;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				value = CACHED_PTR(opline->op2.literal->cache_slot);
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else if (CACHED_PTR(opline->op1.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op1.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op1.zv), Z_STRLEN_P(opline->op1.zv), opline->op1.literal + 1, opline->extended_value TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op1.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op1.var).class_entry;
			if ((value = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce)) != NULL) {
				ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
				zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
		}

		if (EXPECTED(zend_hash_quick_find(&ce->constants_table, Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv)+1, Z_HASH_P(opline->op2.zv), (void **) &value) == SUCCESS)) {
			if (Z_TYPE_PP(value) == IS_CONSTANT_ARRAY ||
			    (Z_TYPE_PP(value) & IS_CONSTANT_TYPE_MASK) == IS_CONSTANT) {
				zend_class_entry *old_scope = EG(scope);

				EG(scope) = ce;
				zval_update_constant(value, (void *) 1 TSRMLS_CC);
				EG(scope) = old_scope;
			}
			if (IS_UNUSED == IS_CONST) {
				CACHE_PTR(opline->op2.literal->cache_slot, value);
			} else {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, ce, value);
			}
			ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, *value);
			zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
		} else {
			zend_error_noreturn(E_ERROR, "Undefined class constant '%s'", Z_STRVAL_P(opline->op2.zv));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1790: /*ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_CONST_LABEL;
#endif
	}
}

case 1890: /*ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE

	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = opline->op2.zv;

	if (IS_UNUSED != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CONST == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_UNUSED_CONST);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_UNUSED_CONST:
						zend_hash_index_del(ht, hval);
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1915: /*ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE

	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	offset = opline->op2.zv;

	if (IS_UNUSED != IS_VAR || container) {
		if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST:
{
	USE_OPLINE

	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	offset = opline->op2.zv;

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_UNUSED_CONST;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_UNUSED_CONST:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_UNUSED_CONST);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2890: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST;
}

case 3715: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST;
}

case 4015: /*ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP:
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_UNUSED_TMP:
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP;
				} else {
					zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
		zval_dtor(free_op2.var);

		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}
	zval_dtor(free_op2.var);

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 591: /*ZEND_ASSIGN_ADD_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 616: /*ZEND_ASSIGN_SUB_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 641: /*ZEND_ASSIGN_MUL_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 666: /*ZEND_ASSIGN_DIV_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 691: /*ZEND_ASSIGN_MOD_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 716: /*ZEND_ASSIGN_SL_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 741: /*ZEND_ASSIGN_SR_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 766: /*ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 791: /*ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 816: /*ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

case 841: /*ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMP_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_TMP;
}

zend_pre_incdec_property_helper_SPEC_UNUSED_TMP:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3316: /*ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMP_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_UNUSED_TMP;
}

case 3341: /*ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_UNUSED_TMP;
}

zend_post_incdec_property_helper_SPEC_UNUSED_TMP:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3366: /*ZEND_POST_INC_OBJ_SPEC_UNUSED_TMP_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_UNUSED_TMP;
}

case 3391: /*ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_UNUSED_TMP;
}

zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP:
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2066: /*ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMP_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP;
}

case 2141: /*ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2216: /*ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2291: /*ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2366: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP;
	}
}

case 2441: /*ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3416: /*ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property_name);
	} else {
		zval_dtor(free_op2.var);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 1416: /*ZEND_ADD_VAR_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2816: /*ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1791: /*ZEND_INIT_ARRAY_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_TMP_LABEL;
#endif
	}
}

case 1891: /*ZEND_UNSET_DIM_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_TMP_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_UNUSED_TMP);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_UNUSED_TMP:
						zend_hash_index_del(ht, hval);
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				zval_dtor(free_op2.var);
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (1) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (1) {
					zval_ptr_dtor(&offset);
				} else {
					zval_dtor(free_op2.var);
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				zval_dtor(free_op2.var);
				break;
		}
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1916: /*ZEND_UNSET_OBJ_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (1) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (1) {
				zval_ptr_dtor(&offset);
			} else {
				zval_dtor(free_op2.var);
			}
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_UNUSED_TMP;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_UNUSED_TMP:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_UNUSED_TMP);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		zval_dtor(free_op2.var);
	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		zval_dtor(free_op2.var);
	} else {
		zval_dtor(free_op2.var);
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2891: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMP_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP;
}

case 3716: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMP_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP;
}

case 4016: /*ZEND_YIELD_SPEC_UNUSED_TMP_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR:
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_UNUSED_VAR:
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR;
				} else {
					zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 592: /*ZEND_ASSIGN_ADD_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 617: /*ZEND_ASSIGN_SUB_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 642: /*ZEND_ASSIGN_MUL_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 667: /*ZEND_ASSIGN_DIV_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 692: /*ZEND_ASSIGN_MOD_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 717: /*ZEND_ASSIGN_SL_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 742: /*ZEND_ASSIGN_SR_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 767: /*ZEND_ASSIGN_CONCAT_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 792: /*ZEND_ASSIGN_BW_OR_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 817: /*ZEND_ASSIGN_BW_AND_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

case 842: /*ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_VAR_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_VAR;
}

zend_pre_incdec_property_helper_SPEC_UNUSED_VAR:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3317: /*ZEND_PRE_INC_OBJ_SPEC_UNUSED_VAR_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_UNUSED_VAR;
}

case 3342: /*ZEND_PRE_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_UNUSED_VAR;
}

zend_post_incdec_property_helper_SPEC_UNUSED_VAR:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3367: /*ZEND_POST_INC_OBJ_SPEC_UNUSED_VAR_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_UNUSED_VAR;
}

case 3392: /*ZEND_POST_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_UNUSED_VAR;
}

zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR:
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2067: /*ZEND_FETCH_OBJ_R_SPEC_UNUSED_VAR_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR;
}

case 2142: /*ZEND_FETCH_OBJ_W_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2217: /*ZEND_FETCH_OBJ_RW_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2292: /*ZEND_FETCH_OBJ_IS_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2367: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR;
	}
}

case 2442: /*ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3417: /*ZEND_ASSIGN_OBJ_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 1417: /*ZEND_ADD_VAR_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2817: /*ZEND_INIT_METHOD_CALL_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1792: /*ZEND_INIT_ARRAY_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_VAR_LABEL;
#endif
	}
}

case 1892: /*ZEND_UNSET_DIM_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_UNUSED_VAR);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_UNUSED_VAR:
						zend_hash_index_del(ht, hval);
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {
					if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
				break;
		}
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1917: /*ZEND_UNSET_OBJ_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
			}
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_UNUSED_VAR;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_UNUSED_VAR:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_UNUSED_VAR);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2892: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_VAR_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR;
}

case 3717: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_VAR_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR;
}

case 4017: /*ZEND_YIELD_SPEC_UNUSED_VAR_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = NULL;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED;
				} else {
					zval *dim = NULL;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_UNUSED, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = NULL;
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 593: /*ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 618: /*ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 643: /*ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 668: /*ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 693: /*ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 718: /*ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 743: /*ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 768: /*ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 793: /*ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 818: /*ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 843: /*ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED;
}

case 1793: /*ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_UNUSED_LABEL;
#endif
	}
}

case 4018: /*ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV:
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	zval *object;
	zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_UNUSED_CV:
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

				if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_UNUSED == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV;
				} else {
					zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CV, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
			var_ptr = NULL;
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 594: /*ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 619: /*ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 644: /*ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 669: /*ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 694: /*ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 719: /*ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 744: /*ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 769: /*ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 794: /*ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 819: /*ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

case 844: /*ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_UNUSED_CV;
}

zend_pre_incdec_property_helper_SPEC_UNUSED_CV:
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3319: /*ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_UNUSED_CV;
}

case 3344: /*ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_UNUSED_CV;
}

zend_post_incdec_property_helper_SPEC_UNUSED_CV:
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3369: /*ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_UNUSED_CV;
}

case 3394: /*ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_UNUSED_CV;
}

zend_fetch_property_address_read_helper_SPEC_UNUSED_CV:
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2069: /*ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_UNUSED_CV;
}

case 2144: /*ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2219: /*ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2294: /*ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2369: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_UNUSED_CV;
	}
}

case 2444: /*ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3419: /*ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE

	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_UNUSED == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 1419: /*ZEND_ADD_VAR_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE

	zval *str = &EX_T(opline->result.var).tmp_var;
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;

		INIT_PZVAL(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		zend_make_printable_zval(var, &var_copy, &use_copy);

		if (use_copy) {
			var = &var_copy;
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2819: /*ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;

	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1794: /*ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_CV_LABEL;
#endif
	}
}

case 1894: /*ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE

	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CV == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_UNUSED_CV);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_UNUSED_CV:
						zend_hash_index_del(ht, hval);
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1919: /*ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE

	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED != IS_VAR || container) {
		if (IS_UNUSED == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV:
{
	USE_OPLINE

	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_ptr_unused(TSRMLS_C);

	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_UNUSED_CV;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_UNUSED_CV:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_UNUSED_CV);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2894: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV;
}

case 3719: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV;
}

case 4019: /*ZEND_YIELD_SPEC_UNUSED_CV_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 320: /*ZEND_BW_NOT_SPEC_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 345: /*ZEND_BOOL_NOT_SPEC_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_not_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 870: /*ZEND_PRE_INC_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval **var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_increment_function(*var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 895: /*ZEND_PRE_DEC_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval **var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_decrement_function(*var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 920: /*ZEND_POST_INC_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval **var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		ZVAL_NULL(&EX_T(opline->result.var).tmp_var);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = &EX_T(opline->result.var).tmp_var;
	ZVAL_COPY_VALUE(retval, *var_ptr);
	zendi_zval_copy_ctor(*retval);

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_increment_function(*var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 945: /*ZEND_POST_DEC_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval **var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(*var_ptr == &EG(error_zval))) {
		ZVAL_NULL(&EX_T(opline->result.var).tmp_var);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = &EX_T(opline->result.var).tmp_var;
	ZVAL_COPY_VALUE(retval, *var_ptr);
	zendi_zval_copy_ctor(*retval);

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *val = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(&val);
	} else {
		fast_decrement_function(*var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1020: /*ZEND_ECHO_SPEC_CV_HANDLER*/ ZEND_ECHO_SPEC_CV_LABEL:
{
	USE_OPLINE

	zval z_copy;
	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) &&
	    Z_OBJ_HT_P(z)->get_method != NULL) {
	    if (IS_CV == IS_TMP_VAR) {
	    	INIT_PZVAL(z);
	    }
		if (zend_std_cast_object_tostring(z, &z_copy, IS_STRING TSRMLS_CC) == SUCCESS) {
			zend_print_variable(&z_copy);
			zval_dtor(&z_copy);
		} else {
			zend_print_variable(z);
		}
	} else {
		zend_print_variable(z);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1045: /*ZEND_PRINT_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	ZVAL_LONG(&EX_T(opline->result.var).tmp_var, 1);
	goto ZEND_ECHO_SPEC_CV_LABEL;
}

case 1095: /*ZEND_JMPZ_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

case 1120: /*ZEND_JMPNZ_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

case 1145: /*ZEND_JMPZNZ_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

case 1170: /*ZEND_JMPZ_EX_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1195: /*ZEND_JMPNZ_EX_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	Z_LVAL(EX_T(opline->result.var).tmp_var) = retval;
	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1570: /*ZEND_RETURN_SPEC_CV_HANDLER*/
{
	USE_OPLINE
	zval *retval_ptr;


	SAVE_OPLINE();
	retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (!EG(return_value_ptr_ptr)) {
		if (IS_CV == IS_TMP_VAR) {

		}
	} else if (!0) { /* Not a temp var */
		if (*EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}
		if (IS_CV == IS_CONST ||
		    (PZVAL_IS_REF(retval_ptr) && Z_REFCOUNT_P(retval_ptr) > 0)) {
			zval *ret;

			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, retval_ptr);
			zval_copy_ctor(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else if ((IS_CV == IS_CV || IS_CV == IS_VAR) &&
		           retval_ptr == &EG(uninitialized_zval)) {
			zval *ret;

			ALLOC_INIT_ZVAL(ret);
			*EG(return_value_ptr_ptr) = ret;
		} else {
			*EG(return_value_ptr_ptr) = retval_ptr;
			Z_ADDREF_P(retval_ptr);
		}
	} else {
		zval *ret;

		if (*EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}

		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, retval_ptr);
		*EG(return_value_ptr_ptr) = ret;
	}

	goto zend_leave_helper_SPEC;
}

case 2795: /*ZEND_RETURN_BY_REF_SPEC_CV_HANDLER*/
{
	USE_OPLINE
	zval *retval_ptr;
	zval **retval_ptr_ptr;


	SAVE_OPLINE();

	do {
		if (EG(return_value_ptr_ptr) && *EG(return_value_ptr_ptr)) {
			zval_ptr_dtor(EG(return_value_ptr_ptr));
		}

		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
			if (!EG(return_value_ptr_ptr)) {
				if (IS_CV == IS_TMP_VAR) {

				}
			} else if (!0) { /* Not a temp var */
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				zval_copy_ctor(ret);
				*EG(return_value_ptr_ptr) = ret;
			} else {
				zval *ret;

				ALLOC_ZVAL(ret);
				INIT_PZVAL_COPY(ret, retval_ptr);
				*EG(return_value_ptr_ptr) = ret;
			}
			break;
		}

		retval_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(retval_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_CV == IS_VAR && !Z_ISREF_PP(retval_ptr_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    EX_T(opline->op1.var).var.fcall_returned_reference) {
			} else if (EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EG(return_value_ptr_ptr)) {
					retval_ptr = *retval_ptr_ptr;
					*EG(return_value_ptr_ptr) = retval_ptr;
					Z_ADDREF_P(retval_ptr);
				}
				break;
			}
		}

		if (EG(return_value_ptr_ptr)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr);
			Z_ADDREF_PP(retval_ptr_ptr);

			*EG(return_value_ptr_ptr) = *retval_ptr_ptr;
		}
	} while (0);

	goto zend_leave_helper_SPEC;
}

case 2720: /*ZEND_THROW_SPEC_CV_HANDLER*/
{
	USE_OPLINE
	zval *value;
	zval *exception;


	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}
	zend_exception_save(TSRMLS_C);
	/* Not sure if a complete copy is what we want here */
	ALLOC_ZVAL(exception);
	INIT_PZVAL_COPY(exception, value);
	if (!0) {
		zval_copy_ctor(exception);
	}

	zend_throw_exception_object(exception TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	HANDLE_EXCEPTION();
}

zend_send_by_var_helper_SPEC_CV:
{
	USE_OPLINE
	zval *varptr;

	varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (varptr == &EG(uninitialized_zval)) {
		ALLOC_ZVAL(varptr);
		INIT_ZVAL(*varptr);
		Z_SET_REFCOUNT_P(varptr, 0);
	} else if (PZVAL_IS_REF(varptr)) {
		zval *original_var = varptr;

		ALLOC_ZVAL(varptr);
		ZVAL_COPY_VALUE(varptr, original_var);
		Z_UNSET_ISREF_P(varptr);
		Z_SET_REFCOUNT_P(varptr, 0);
		zval_copy_ctor(varptr);
	}
	Z_ADDREF_P(varptr);
	zend_vm_stack_push(varptr TSRMLS_CC);
	;  /* for string offsets */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2670: /*ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varptr;

	SAVE_OPLINE();
	if (opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) { /* Had function_ptr at compile_time */
		if (!(opline->extended_value & ZEND_ARG_SEND_BY_REF)) {
			goto zend_send_by_var_helper_SPEC_CV;
		}
	} else if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
		goto zend_send_by_var_helper_SPEC_CV;
	}

	if (IS_CV == IS_VAR &&
		(opline->extended_value & ZEND_ARG_SEND_FUNCTION) &&
		EX_T(opline->op1.var).var.fcall_returned_reference &&
		EX_T(opline->op1.var).var.ptr) {
		varptr = EX_T(opline->op1.var).var.ptr;
		PZVAL_UNLOCK_EX(varptr, &free_op1, 0);
	} else {
		varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	}
	if ((!(opline->extended_value & ZEND_ARG_SEND_FUNCTION) ||
	     EX_T(opline->op1.var).var.fcall_returned_reference) &&
	    varptr != &EG(uninitialized_zval) &&
	    (PZVAL_IS_REF(varptr) ||
	     (Z_REFCOUNT_P(varptr) == 1 && (IS_CV == IS_CV || free_op1.var)))) {
		Z_SET_ISREF_P(varptr);
		Z_ADDREF_P(varptr);
		zend_vm_stack_push(varptr TSRMLS_CC);
	} else {
		zval *valptr;

		if ((opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) ?
			!(opline->extended_value & ZEND_ARG_SEND_SILENT) :
			!ARG_MAY_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
			zend_error(E_STRICT, "Only variables should be passed by reference");
		}
		ALLOC_ZVAL(valptr);
		INIT_PZVAL_COPY(valptr, varptr);
		if (!0) {
			zval_copy_ctor(valptr);
		}
		zend_vm_stack_push(valptr TSRMLS_CC);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1695: /*ZEND_SEND_REF_SPEC_CV_HANDLER*/ ZEND_SEND_REF_SPEC_CV_LABEL:
{
	USE_OPLINE

	zval **varptr_ptr;
	zval *varptr;

	SAVE_OPLINE();
	varptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(varptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Only variables can be passed by reference");
	}

	if (IS_CV == IS_VAR && UNEXPECTED(*varptr_ptr == &EG(error_zval))) {
		ALLOC_INIT_ZVAL(varptr);
		zend_vm_stack_push(varptr TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION && !ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
		goto zend_send_by_var_helper_SPEC_CV;
	}

	SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);
	varptr = *varptr_ptr;
	Z_ADDREF_P(varptr);
	zend_vm_stack_push(varptr TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1670: /*ZEND_SEND_VAR_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	if ((opline->extended_value == ZEND_DO_FCALL_BY_NAME)
		&& ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, opline->op2.opline_num)) {
		goto ZEND_SEND_REF_SPEC_CV_LABEL;
	}
	SAVE_OPLINE();
	goto zend_send_by_var_helper_SPEC_CV;
}

case 1320: /*ZEND_BOOL_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *retval = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC)));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2770: /*ZEND_CLONE_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name, EG(scope) ? EG(scope)->name : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		Z_OBJVAL_P(retval) = clone_call(obj TSRMLS_CC);
		Z_TYPE_P(retval) = IS_OBJECT;
		Z_SET_REFCOUNT_P(retval, 1);
		Z_SET_ISREF_P(retval);
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&retval);
		} else {
			AI_SET_PTR(&EX_T(opline->result.var), retval);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 545: /*ZEND_CAST_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *expr;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	expr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!0) {
			zendi_zval_copy_ctor(*result);
		}
	}
	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (0) {

				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!0) {
					zendi_zval_copy_ctor(*result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1845: /*ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER*/
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;

	zval *inc_filename;
	zval *tmp_inc_filename = NULL;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (inc_filename->type!=IS_STRING) {
		MAKE_STD_ZVAL(tmp_inc_filename);
		ZVAL_COPY_VALUE(tmp_inc_filename, inc_filename);
		zval_copy_ctor(tmp_inc_filename);
		convert_to_string(tmp_inc_filename);
		inc_filename = tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_exists(&EG(included_files), resolved_path, strlen(resolved_path)+1);
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==SUCCESS) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (tmp_inc_filename) {
		zval_ptr_dtor(&tmp_inc_filename);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			EX_T(opline->result.var).var.ptr = NULL;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			EG(return_value_ptr_ptr) = EX_T(opline->result.var).var.ptr_ptr;
		} else {
			EG(return_value_ptr_ptr) = NULL;
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		zval *retval;

		ALLOC_ZVAL(retval);
		ZVAL_BOOL(retval, failure_retval);
		INIT_PZVAL(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);
	}
	ZEND_VM_NEXT_OPCODE();
}

case 1945: /*ZEND_FE_RESET_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *array_ptr, **array_ptr_ptr;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_CV == IS_CV || IS_CV == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {
			MAKE_STD_ZVAL(array_ptr);
			ZVAL_NULL(array_ptr);
		} else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_PP(array_ptr_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_PP(array_ptr_ptr);
			if (!ce || ce->get_iterator == NULL) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				Z_ADDREF_PP(array_ptr_ptr);
			}
			array_ptr = *array_ptr_ptr;
		} else {
			if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {
				SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					Z_SET_ISREF_PP(array_ptr_ptr);
				}
			}
			array_ptr = *array_ptr_ptr;
			Z_ADDREF_P(array_ptr);
		}
	} else {
		array_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* IS_TMP_VAR */
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			array_ptr = tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ptr);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				Z_ADDREF_P(array_ptr);
			}
		} else if (IS_CV == IS_CONST ||
		           ((IS_CV == IS_CV || IS_CV == IS_VAR) &&
		            !Z_ISREF_P(array_ptr) &&
		            Z_REFCOUNT_P(array_ptr) > 1)) {
			zval *tmp;

			ALLOC_ZVAL(tmp);
			INIT_PZVAL_COPY(tmp, array_ptr);
			zval_copy_ctor(tmp);
			array_ptr = tmp;
		} else {
			Z_ADDREF_P(array_ptr);
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (iter && EXPECTED(EG(exception) == NULL)) {
			array_ptr = zend_iterator_wrap(iter TSRMLS_CC);
		} else {

			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	EX_T(opline->result.var).fe.ptr = array_ptr;

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(&array_ptr);

				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(&array_ptr);

			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = zend_objects_get_address(array_ptr TSRMLS_CC);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				char *str_key;
				uint str_key_len;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, NULL);
				if (key_type != HASH_KEY_NON_EXISTANT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key, str_key_len-1 TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, &EX_T(opline->result.var).fe.fe_pos);
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

case 1995: /*ZEND_EXIT_SPEC_CV_HANDLER*/
{
#if 0 || (IS_CV != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CV != IS_UNUSED) {

		zval *ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}

	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

case 3820: /*ZEND_JMP_SET_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (i_zend_is_true(value)) {
		ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
		if (!0) {
			zendi_zval_copy_ctor(EX_T(opline->result.var).tmp_var);
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3970: /*ZEND_JMP_SET_VAR_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (i_zend_is_true(value)) {
		if (IS_CV == IS_VAR || IS_CV == IS_CV) {
			Z_ADDREF_P(value);
			EX_T(opline->result.var).var.ptr = value;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		} else {
			ALLOC_ZVAL(ret);
			INIT_PZVAL_COPY(ret, value);
			EX_T(opline->result.var).var.ptr = ret;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
			if (!0) {
				zval_copy_ctor(EX_T(opline->result.var).var.ptr);
			}
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 570: /*ZEND_QM_ASSIGN_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	ZVAL_COPY_VALUE(&EX_T(opline->result.var).tmp_var, value);
	if (!0) {
		zval_copy_ctor(&EX_T(opline->result.var).tmp_var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3945: /*ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *value, *ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		Z_ADDREF_P(value);
		EX_T(opline->result.var).var.ptr = value;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	} else {
		ALLOC_ZVAL(ret);
		INIT_PZVAL_COPY(ret, value);
		EX_T(opline->result.var).var.ptr = ret;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		if (!0) {
			zval_copy_ctor(EX_T(opline->result.var).var.ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3470: /*ZEND_INSTANCEOF_SPEC_CV_HANDLER*/
{
	USE_OPLINE

	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (Z_TYPE_P(expr) == IS_OBJECT && Z_OBJ_HT_P(expr)->get_class_entry) {
		result = instanceof_function(Z_OBJCE_P(expr), EX_T(opline->op2.var).class_entry TSRMLS_CC);
	} else {
		result = 0;
	}
	ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 45: /*ZEND_ADD_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 70: /*ZEND_SUB_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 95: /*ZEND_MUL_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 120: /*ZEND_DIV_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 145: /*ZEND_MOD_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 170: /*ZEND_SL_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 195: /*ZEND_SR_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 220: /*ZEND_CONCAT_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 395: /*ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 420: /*ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 445: /*ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 470: /*ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 495: /*ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 520: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 245: /*ZEND_BW_OR_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 270: /*ZEND_BW_AND_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 295: /*ZEND_BW_XOR_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 370: /*ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_obj_helper_SPEC_CV_CONST:
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = opline->op2.zv;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_CV_CONST:
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_CONST;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_CONST;
				} else {
					zval *dim = opline->op2.zv;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CONST, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = opline->op2.zv;
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 595: /*ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 620: /*ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 645: /*ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 670: /*ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 695: /*ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 720: /*ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 745: /*ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 770: /*ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 795: /*ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 820: /*ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

case 845: /*ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_CV_CONST;
}

zend_pre_incdec_property_helper_SPEC_CV_CONST:
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3320: /*ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_CV_CONST;
}

case 3345: /*ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_CV_CONST;
}

zend_post_incdec_property_helper_SPEC_CV_CONST:
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = opline->op2.zv;
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3370: /*ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_CV_CONST;
}

case 3395: /*ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_CV_CONST;
}

zend_fetch_var_address_helper_SPEC_CV_CONST:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

 	if (IS_CV != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CV == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CV != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CV == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CV != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2020: /*ZEND_FETCH_R_SPEC_CV_CONST_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CV_CONST;
}

case 2095: /*ZEND_FETCH_W_SPEC_CV_CONST_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_CV_CONST;
}

case 2170: /*ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_CV_CONST;
}

case 2320: /*ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CV_CONST;
}

case 2395: /*ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_CV_CONST;
}

case 2245: /*ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_CV_CONST;
}

case 2045: /*ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_CV != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_CV == IS_TMP_VAR || IS_CV == IS_CONST) {
		zval *container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);


	} else {
		container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);


	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2120: /*ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_W TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2195: /*ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_RW TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2270: /*ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_IS TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2345: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_CONST == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2420: /*ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, opline->op2.zv, IS_CONST, BP_VAR_UNSET TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

zend_fetch_property_address_read_helper_SPEC_CV_CONST:
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2070: /*ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_CV_CONST;
}

case 2145: /*ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;

	if (IS_CV == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2220: /*ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = opline->op2.zv;
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2295: /*ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2370: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = opline->op2.zv;
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_CV_CONST;
	}
}

case 2445: /*ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = opline->op2.zv;

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3420: /*ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = opline->op2.zv;

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 3695: /*ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = opline->op2.zv;

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = opline->op2.zv;
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_CONST, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 970: /*ZEND_ASSIGN_SPEC_CV_CONST_HANDLER*/ ZEND_ASSIGN_SPEC_CV_CONST_LABEL:
{
	USE_OPLINE

	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = opline->op2.zv;
	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_CONST TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				AI_SET_PTR(&EX_T(opline->result.var), retval);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else if (IS_CV == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else {
		if (IS_CONST == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_CONST == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			AI_SET_PTR(&EX_T(opline->result.var), value);
		}
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2820: /*ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;

	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CONST == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1220: /*ZEND_CASE_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	if (IS_CV==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 opline->op2.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1820: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CV_CONST;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CV_CONST:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CV_CONST);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1795: /*ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_LABEL;
#endif
	}
}

case 1870: /*ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CV != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1895: /*ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = opline->op2.zv;

	if (IS_CV != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CONST == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_CV_CONST);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_CV_CONST:
						zend_hash_index_del(ht, hval);
						if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1920: /*ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	offset = opline->op2.zv;

	if (IS_CV != IS_VAR || container) {
		if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2870: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CV != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST:
{
	USE_OPLINE

	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

	offset = opline->op2.zv;

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_CV_CONST;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_CV_CONST:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CONST == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_CV_CONST);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CONST == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2895: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST;
}

case 3720: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST;
}

case 4020: /*ZEND_YIELD_SPEC_CV_CONST_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 46: /*ZEND_ADD_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 71: /*ZEND_SUB_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 96: /*ZEND_MUL_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 121: /*ZEND_DIV_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 146: /*ZEND_MOD_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 171: /*ZEND_SL_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 196: /*ZEND_SR_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 221: /*ZEND_CONCAT_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 396: /*ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 421: /*ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 446: /*ZEND_IS_EQUAL_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 471: /*ZEND_IS_NOT_EQUAL_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 496: /*ZEND_IS_SMALLER_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 521: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 246: /*ZEND_BW_OR_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 271: /*ZEND_BW_AND_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 296: /*ZEND_BW_XOR_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 371: /*ZEND_BOOL_XOR_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_obj_helper_SPEC_CV_TMP:
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_CV_TMP:
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_TMP;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_TMP;
				} else {
					zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
		zval_dtor(free_op2.var);

		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}
	zval_dtor(free_op2.var);

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 596: /*ZEND_ASSIGN_ADD_SPEC_CV_TMP_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 621: /*ZEND_ASSIGN_SUB_SPEC_CV_TMP_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 646: /*ZEND_ASSIGN_MUL_SPEC_CV_TMP_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 671: /*ZEND_ASSIGN_DIV_SPEC_CV_TMP_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 696: /*ZEND_ASSIGN_MOD_SPEC_CV_TMP_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 721: /*ZEND_ASSIGN_SL_SPEC_CV_TMP_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 746: /*ZEND_ASSIGN_SR_SPEC_CV_TMP_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 771: /*ZEND_ASSIGN_CONCAT_SPEC_CV_TMP_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 796: /*ZEND_ASSIGN_BW_OR_SPEC_CV_TMP_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 821: /*ZEND_ASSIGN_BW_AND_SPEC_CV_TMP_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

case 846: /*ZEND_ASSIGN_BW_XOR_SPEC_CV_TMP_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_CV_TMP;
}

zend_pre_incdec_property_helper_SPEC_CV_TMP:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3321: /*ZEND_PRE_INC_OBJ_SPEC_CV_TMP_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_CV_TMP;
}

case 3346: /*ZEND_PRE_DEC_OBJ_SPEC_CV_TMP_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_CV_TMP;
}

zend_post_incdec_property_helper_SPEC_CV_TMP:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3371: /*ZEND_POST_INC_OBJ_SPEC_CV_TMP_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_CV_TMP;
}

case 3396: /*ZEND_POST_DEC_OBJ_SPEC_CV_TMP_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_CV_TMP;
}

case 2046: /*ZEND_FETCH_DIM_R_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_CV != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_CV == IS_TMP_VAR || IS_CV == IS_CONST) {
		zval *container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);

	} else {
		container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
		zval_dtor(free_op2.var);

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2121: /*ZEND_FETCH_DIM_W_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2196: /*ZEND_FETCH_DIM_RW_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_RW TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2271: /*ZEND_FETCH_DIM_IS_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_IS TSRMLS_CC);
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2346: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_TMP_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_R TSRMLS_CC);
	}
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2421: /*ZEND_FETCH_DIM_UNSET_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR, BP_VAR_UNSET TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

zend_fetch_property_address_read_helper_SPEC_CV_TMP:
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2071: /*ZEND_FETCH_OBJ_R_SPEC_CV_TMP_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_CV_TMP;
}

case 2146: /*ZEND_FETCH_OBJ_W_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2221: /*ZEND_FETCH_OBJ_RW_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2296: /*ZEND_FETCH_OBJ_IS_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		zval_dtor(free_op2.var);
	} else {
		zval *retval;

		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2371: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property);
		} else {
			zval_dtor(free_op2.var);
		}
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_CV_TMP;
	}
}

case 2446: /*ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (1) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property);
	} else {
		zval_dtor(free_op2.var);
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3421: /*ZEND_ASSIGN_OBJ_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (1) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (1) {
		zval_ptr_dtor(&property_name);
	} else {
		zval_dtor(free_op2.var);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 3696: /*ZEND_ASSIGN_DIM_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (1) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (1) {
			zval_ptr_dtor(&property_name);
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_TMP_VAR, BP_VAR_W TSRMLS_CC);
		zval_dtor(free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 971: /*ZEND_ASSIGN_SPEC_CV_TMP_HANDLER*/ ZEND_ASSIGN_SPEC_CV_TMP_LABEL:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_TMP_VAR TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				AI_SET_PTR(&EX_T(opline->result.var), retval);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else if (IS_CV == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (1) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else {
		if (IS_TMP_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_TMP_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			AI_SET_PTR(&EX_T(opline->result.var), value);
		}
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2821: /*ZEND_INIT_METHOD_CALL_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_TMP_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1221: /*ZEND_CASE_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	if (IS_CV==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1821: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CV_TMP;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CV_TMP:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CV_TMP);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1796: /*ZEND_INIT_ARRAY_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_LABEL;
#endif
	}
}

case 1896: /*ZEND_UNSET_DIM_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_TMP_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_CV_TMP);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_CV_TMP:
						zend_hash_index_del(ht, hval);
						if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				zval_dtor(free_op2.var);
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (1) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (1) {
					zval_ptr_dtor(&offset);
				} else {
					zval_dtor(free_op2.var);
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				zval_dtor(free_op2.var);
				break;
		}
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1921: /*ZEND_UNSET_OBJ_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (1) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (1) {
				zval_ptr_dtor(&offset);
			} else {
				zval_dtor(free_op2.var);
			}
		} else {
			zval_dtor(free_op2.var);
		}
	} else {
		zval_dtor(free_op2.var);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_CV_TMP;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_CV_TMP:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_TMP_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_CV_TMP);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		zval_dtor(free_op2.var);
	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (1) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_TMP_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (1) {
			zval_ptr_dtor(&offset);
		} else {
			zval_dtor(free_op2.var);
		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		zval_dtor(free_op2.var);
	} else {
		zval_dtor(free_op2.var);
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2896: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMP_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP;
}

case 3721: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMP_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP;
}

case 4021: /*ZEND_YIELD_SPEC_CV_TMP_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!1) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 47: /*ZEND_ADD_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 72: /*ZEND_SUB_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 97: /*ZEND_MUL_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 122: /*ZEND_DIV_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 147: /*ZEND_MOD_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 172: /*ZEND_SL_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 197: /*ZEND_SR_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 222: /*ZEND_CONCAT_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 397: /*ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 422: /*ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 447: /*ZEND_IS_EQUAL_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 472: /*ZEND_IS_NOT_EQUAL_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 497: /*ZEND_IS_SMALLER_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 522: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 247: /*ZEND_BW_OR_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 272: /*ZEND_BW_AND_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 297: /*ZEND_BW_XOR_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 372: /*ZEND_BOOL_XOR_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_obj_helper_SPEC_CV_VAR:
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_CV_VAR:
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_VAR;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_VAR;
				} else {
					zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_VAR, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 597: /*ZEND_ASSIGN_ADD_SPEC_CV_VAR_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 622: /*ZEND_ASSIGN_SUB_SPEC_CV_VAR_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 647: /*ZEND_ASSIGN_MUL_SPEC_CV_VAR_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 672: /*ZEND_ASSIGN_DIV_SPEC_CV_VAR_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 697: /*ZEND_ASSIGN_MOD_SPEC_CV_VAR_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 722: /*ZEND_ASSIGN_SL_SPEC_CV_VAR_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 747: /*ZEND_ASSIGN_SR_SPEC_CV_VAR_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 772: /*ZEND_ASSIGN_CONCAT_SPEC_CV_VAR_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 797: /*ZEND_ASSIGN_BW_OR_SPEC_CV_VAR_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 822: /*ZEND_ASSIGN_BW_AND_SPEC_CV_VAR_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

case 847: /*ZEND_ASSIGN_BW_XOR_SPEC_CV_VAR_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_CV_VAR;
}

zend_pre_incdec_property_helper_SPEC_CV_VAR:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3322: /*ZEND_PRE_INC_OBJ_SPEC_CV_VAR_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_CV_VAR;
}

case 3347: /*ZEND_PRE_DEC_OBJ_SPEC_CV_VAR_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_CV_VAR;
}

zend_post_incdec_property_helper_SPEC_CV_VAR:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3372: /*ZEND_POST_INC_OBJ_SPEC_CV_VAR_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_CV_VAR;
}

case 3397: /*ZEND_POST_DEC_OBJ_SPEC_CV_VAR_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_CV_VAR;
}

zend_fetch_var_address_helper_SPEC_CV_VAR:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

 	if (IS_CV != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CV == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CV != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CV == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CV != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2022: /*ZEND_FETCH_R_SPEC_CV_VAR_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CV_VAR;
}

case 2097: /*ZEND_FETCH_W_SPEC_CV_VAR_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_CV_VAR;
}

case 2172: /*ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_CV_VAR;
}

case 2322: /*ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CV_VAR;
}

case 2397: /*ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_CV_VAR;
}

case 2247: /*ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_CV_VAR;
}

case 2047: /*ZEND_FETCH_DIM_R_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_CV != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_CV == IS_TMP_VAR || IS_CV == IS_CONST) {
		zval *container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	} else {
		container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2122: /*ZEND_FETCH_DIM_W_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_W TSRMLS_CC);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2197: /*ZEND_FETCH_DIM_RW_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_RW TSRMLS_CC);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2272: /*ZEND_FETCH_DIM_IS_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_IS TSRMLS_CC);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2347: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_R TSRMLS_CC);
	}
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2422: /*ZEND_FETCH_DIM_UNSET_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR, BP_VAR_UNSET TSRMLS_CC);
	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

zend_fetch_property_address_read_helper_SPEC_CV_VAR:
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2072: /*ZEND_FETCH_OBJ_R_SPEC_CV_VAR_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_CV_VAR;
}

case 2147: /*ZEND_FETCH_OBJ_W_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2222: /*ZEND_FETCH_OBJ_RW_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2297: /*ZEND_FETCH_OBJ_IS_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2372: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_CV_VAR;
	}
}

case 2447: /*ZEND_FETCH_OBJ_UNSET_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3422: /*ZEND_ASSIGN_OBJ_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 3697: /*ZEND_ASSIGN_DIM_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_VAR, BP_VAR_W TSRMLS_CC);
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 972: /*ZEND_ASSIGN_SPEC_CV_VAR_HANDLER*/ ZEND_ASSIGN_SPEC_CV_VAR_LABEL:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_VAR TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				AI_SET_PTR(&EX_T(opline->result.var), retval);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else if (IS_CV == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else {
		if (IS_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			AI_SET_PTR(&EX_T(opline->result.var), value);
		}
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */
 	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 997: /*ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **variable_ptr_ptr;
	zval **value_ptr_ptr;

	SAVE_OPLINE();
	value_ptr_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR &&
	    value_ptr_ptr &&
	    !Z_ISREF_PP(value_ptr_ptr) &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !EX_T(opline->op2.var).var.fcall_returned_reference) {
		if (free_op2.var == NULL) {
			PZVAL_LOCK(*value_ptr_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
			HANDLE_EXCEPTION();
		}
		goto ZEND_ASSIGN_SPEC_CV_VAR_LABEL;
	} else if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		PZVAL_LOCK(*value_ptr_ptr);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr)) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}

	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if ((IS_VAR == IS_VAR && UNEXPECTED(value_ptr_ptr == NULL)) ||
	    (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr TSRMLS_CC);

	if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		Z_DELREF_PP(variable_ptr_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*variable_ptr_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *variable_ptr_ptr);
	}

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2822: /*ZEND_INIT_METHOD_CALL_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_VAR == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1222: /*ZEND_CASE_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	if (IS_CV==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1822: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CV_VAR;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CV_VAR:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CV_VAR);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1797: /*ZEND_INIT_ARRAY_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_LABEL;
#endif
	}
}

case 1872: /*ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CV != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1897: /*ZEND_UNSET_DIM_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_VAR == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_CV_VAR);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_CV_VAR:
						zend_hash_index_del(ht, hval);
						if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {
					if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
				break;
		}
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1922: /*ZEND_UNSET_OBJ_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {
				if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
			}
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2872: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CV != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR:
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_CV_VAR;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_CV_VAR:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_VAR == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_CV_VAR);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_VAR == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {
			if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2897: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_VAR_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR;
}

case 3722: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_VAR_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR;
}

case 4022: /*ZEND_YIELD_SPEC_CV_VAR_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

		if (free_op2.var) {zval_ptr_dtor(&free_op2.var);};
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = NULL;
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_CV_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED;
				} else {
					zval *dim = NULL;

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_UNUSED, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = NULL;
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 598: /*ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 623: /*ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 648: /*ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 673: /*ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 698: /*ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 723: /*ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 748: /*ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 773: /*ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 798: /*ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 823: /*ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

case 848: /*ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_CV_UNUSED;
}

zend_fetch_var_address_helper_SPEC_CV_UNUSED:
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval **retval;
	zval tmp_varname;
	HashTable *target_symbol_table;
	ulong hash_value;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

 	if (IS_CV != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_COPY_VALUE(&tmp_varname, varname);
		zval_copy_ctor(&tmp_varname);
		Z_SET_REFCOUNT(tmp_varname, 1);
		Z_UNSET_ISREF(tmp_varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp_varname) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		retval = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
/*
		if (!target_symbol_table) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
*/
		if (IS_CV == IS_CONST) {
			hash_value = Z_HASH_P(varname);
		} else if (IS_INTERNED(Z_STRVAL_P(varname))) {
			hash_value = INTERNED_HASH(Z_STRVAL_P(varname));
		} else {
			hash_value = zend_hash_func(Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1);
		}

		if (zend_hash_quick_find(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					Z_ADDREF_P(&EG(uninitialized_zval));
					zend_hash_quick_update(target_symbol_table, Z_STRVAL_P(varname), Z_STRLEN_P(varname)+1, hash_value, &EG(uninitialized_zval_ptr), sizeof(zval *), (void **) &retval);
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		}
		switch (opline->extended_value & ZEND_FETCH_TYPE_MASK) {
			case ZEND_FETCH_GLOBAL:
				if (IS_CV != IS_TMP_VAR) {

				}
				break;
			case ZEND_FETCH_LOCAL:

				break;
			case ZEND_FETCH_STATIC:
				zval_update_constant(retval, (void*) 1 TSRMLS_CC);
				break;
			case ZEND_FETCH_GLOBAL_LOCK:
				if (IS_CV == IS_VAR && !free_op1.var) {
					PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
				}
				break;
		}
	}


	if (IS_CV != IS_CONST && varname == &tmp_varname) {
		zval_dtor(&tmp_varname);
	}
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
	}
	PZVAL_LOCK(*retval);
	switch (type) {
		case BP_VAR_R:
		case BP_VAR_IS:
			AI_SET_PTR(&EX_T(opline->result.var), *retval);
			break;
		case BP_VAR_UNSET: {
			zend_free_op free_res;

			PZVAL_UNLOCK(*retval, &free_res);
			if (retval != &EG(uninitialized_zval_ptr)) {
				SEPARATE_ZVAL_IF_NOT_REF(retval);
			}
			PZVAL_LOCK(*retval);
			FREE_OP_VAR_PTR(free_res);
		}
		/* break missing intentionally */
		default:
			EX_T(opline->result.var).var.ptr_ptr = retval;
			break;
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2023: /*ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER*/
{
	type = BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CV_UNUSED;
}

case 2098: /*ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER*/
{
	type = BP_VAR_W; goto zend_fetch_var_address_helper_SPEC_CV_UNUSED;
}

case 2173: /*ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER*/
{
	type = BP_VAR_RW; goto zend_fetch_var_address_helper_SPEC_CV_UNUSED;
}

case 2323: /*ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER*/
{
	USE_OPLINE

	type = ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))?BP_VAR_W:BP_VAR_R; goto zend_fetch_var_address_helper_SPEC_CV_UNUSED;
}

case 2398: /*ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER*/
{
	type = BP_VAR_UNSET; goto zend_fetch_var_address_helper_SPEC_CV_UNUSED;
}

case 2248: /*ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER*/
{
	type = BP_VAR_IS; goto zend_fetch_var_address_helper_SPEC_CV_UNUSED;
}

case 2123: /*ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_W TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2198: /*ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_RW TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2348: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, NULL, IS_UNUSED, BP_VAR_R TSRMLS_CC);
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3698: /*ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER*/
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = NULL;

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_UNUSED == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = NULL;
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_UNUSED, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 1823: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CV_UNUSED;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CV_UNUSED:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_UNUSED == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CV_UNUSED);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1798: /*ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_LABEL;
#endif
	}
}

case 1873: /*ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;


	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			zend_delete_variable(EX(prev_execute_data), EG(active_symbol_table),  cv->name, cv->name_len+1, cv->hash_value TSRMLS_CC);
			EX_CV(opline->op1.var) = NULL;
		} else if (EX_CV(opline->op1.var)) {
			zval_ptr_dtor(EX_CV(opline->op1.var));
			EX_CV(opline->op1.var) = NULL;
		}
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_COPY_VALUE(&tmp, varname);
		zval_copy_ctor(&tmp);
		convert_to_string(&tmp);
		varname = &tmp;
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		Z_ADDREF_P(varname);
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(opline->op2.literal->cache_slot)) {
				ce = CACHED_PTR(opline->op2.literal->cache_slot);
			} else {
				ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST && varname == &tmp) {
						zval_dtor(&tmp);
					} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
						zval_ptr_dtor(&varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(opline->op2.literal->cache_slot, ce);
			}
		} else {
			ce = EX_T(opline->op2.var).class_entry;
		}
		zend_std_unset_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
	} else {
		ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value TSRMLS_CC);
	}

	if (IS_CV != IS_CONST && varname == &tmp) {
		zval_dtor(&tmp);
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		zval_ptr_dtor(&varname);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2873: /*ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER*/
{
	USE_OPLINE
	zval **value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (EX_CV(opline->op1.var)) {
			value = EX_CV(opline->op1.var);
		} else if (EG(active_symbol_table)) {
			zend_compiled_variable *cv = &CV_DEF_OF(opline->op1.var);

			if (zend_hash_quick_find(EG(active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == FAILURE) {
				isset = 0;
			}
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_COPY_VALUE(&tmp, varname);
			zval_copy_ctor(&tmp);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(opline->op2.literal->cache_slot)) {
					ce = CACHED_PTR(opline->op2.literal->cache_slot);
				} else {
					ce = zend_fetch_class_by_name(Z_STRVAL_P(opline->op2.zv), Z_STRLEN_P(opline->op2.zv), opline->op2.literal + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(opline->op2.literal->cache_slot, ce);
				}
			} else {
				ce = EX_T(opline->op2.var).class_entry;
			}
			value = zend_std_get_static_property(ce, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 1, ((IS_CV == IS_CONST) ? opline->op1.literal : NULL) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == FAILURE) {
				isset = 0;
			}
		}

		if (IS_CV != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_PP(value) != IS_NULL) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(*value)) {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 1);
		} else {
			ZVAL_BOOL(&EX_T(opline->result.var).tmp_var, 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 4023: /*ZEND_YIELD_SPEC_CV_UNUSED_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

case 49: /*ZEND_ADD_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 74: /*ZEND_SUB_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 99: /*ZEND_MUL_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 124: /*ZEND_DIV_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 149: /*ZEND_MOD_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 174: /*ZEND_SL_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 199: /*ZEND_SR_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 224: /*ZEND_CONCAT_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 399: /*ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 424: /*ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 449: /*ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 474: /*ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 499: /*ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 524: /*ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval *result = &EX_T(opline->result.var).tmp_var;

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 249: /*ZEND_BW_OR_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 274: /*ZEND_BW_AND_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 299: /*ZEND_BW_XOR_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 374: /*ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(&EX_T(opline->result.var).tmp_var,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_obj_helper_SPEC_CV_CV:
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *object;
	zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	zval *value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	make_real_object(object_ptr TSRMLS_CC);
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
			EX_T(opline->result.var).var.ptr_ptr = NULL;
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}

		/* here property is a string */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(*zptr, *zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(*zptr);
					EX_T(opline->result.var).var.ptr = *zptr;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						GC_REMOVE_ZVAL_FROM_BUFFER(z);
						zval_dtor(z);
						FREE_ZVAL(z);
					}
					z = value;
				}
				Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(&z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(z);
					EX_T(opline->result.var).var.ptr = z;
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
				zval_ptr_dtor(&z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					PZVAL_LOCK(&EG(uninitialized_zval));
					EX_T(opline->result.var).var.ptr = &EG(uninitialized_zval);
					EX_T(opline->result.var).var.ptr_ptr = NULL;
				}
			}
		}

		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

zend_binary_assign_op_helper_SPEC_CV_CV:
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval **var_ptr;
	zval *value;

	SAVE_OPLINE();
	switch (opline->extended_value) {
		case ZEND_ASSIGN_OBJ:
			binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_CV;
			break;
		case ZEND_ASSIGN_DIM: {
				zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
				} else if (UNEXPECTED(Z_TYPE_PP(container) == IS_OBJECT)) {
					if (IS_CV == IS_VAR && !0) {
						Z_ADDREF_PP(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
					}
					binary_op = binary_op; goto zend_binary_assign_op_obj_helper_SPEC_CV_CV;
				} else {
					zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

					zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), container, dim, IS_CV, BP_VAR_RW TSRMLS_CC);
					value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
					var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
				}
			}
			break;
		default:
			value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
			var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
			/* do nothing */
			break;
	}

	if (UNEXPECTED(var_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(*var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}


		CHECK_EXCEPTION();
		if (opline->extended_value == ZEND_ASSIGN_DIM) {
			ZEND_VM_INC_OPCODE();
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);

	if (UNEXPECTED(Z_TYPE_PP(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_PP(var_ptr, get)
	   && Z_OBJ_HANDLER_PP(var_ptr, set)) {
		/* proxy object */
		zval *objval = Z_OBJ_HANDLER_PP(var_ptr, get)(*var_ptr TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_PP(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(&objval);
	} else {
		binary_op(*var_ptr, *var_ptr, value TSRMLS_CC);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*var_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *var_ptr);
	}

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		FREE_OP(free_op_data1);
		FREE_OP_VAR_PTR(free_op_data2);

		CHECK_EXCEPTION();
		ZEND_VM_INC_OPCODE();
	} else {

		CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

case 599: /*ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER*/
{
	binary_op = add_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 624: /*ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER*/
{
	binary_op = sub_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 649: /*ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER*/
{
	binary_op = mul_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 674: /*ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER*/
{
	binary_op = div_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 699: /*ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER*/
{
	binary_op = mod_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 724: /*ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER*/
{
	binary_op = shift_left_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 749: /*ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER*/
{
	binary_op = shift_right_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 774: /*ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER*/
{
	binary_op = concat_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 799: /*ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER*/
{
	binary_op = bitwise_or_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 824: /*ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER*/
{
	binary_op = bitwise_and_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

case 849: /*ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER*/
{
	binary_op = bitwise_xor_function; goto zend_binary_assign_op_helper_SPEC_CV_CV;
}

zend_pre_incdec_property_helper_SPEC_CV_CV:
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval **retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).var.ptr;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			*retval = &EG(uninitialized_zval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(*zptr);
			if (RETURN_VALUE_USED(opline)) {
				*retval = *zptr;
				PZVAL_LOCK(*retval);
			}
		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(&z);
			incdec_op(z);
			*retval = z;
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(*retval, opline);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				*retval = &EG(uninitialized_zval);
			}
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3324: /*ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER*/
{
	incdec_op = increment_function; goto zend_pre_incdec_property_helper_SPEC_CV_CV;
}

case 3349: /*ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER*/
{
	incdec_op = decrement_function; goto zend_pre_incdec_property_helper_SPEC_CV_CV;
}

zend_post_incdec_property_helper_SPEC_CV_CV:
{
	USE_OPLINE

	zval **object_ptr;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = &EX_T(opline->result.var).tmp_var;

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	make_real_object(object_ptr TSRMLS_CC); /* this should modify object only if it's empty */
	object = *object_ptr;

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval **zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_COPY_VALUE(retval, *zptr);
			zendi_zval_copy_ctor(*retval);

			incdec_op(*zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval *z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval *value = Z_OBJ_HT_P(z)->get(z TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					GC_REMOVE_ZVAL_FROM_BUFFER(z);
					zval_dtor(z);
					FREE_ZVAL(z);
				}
				z = value;
			}
			ZVAL_COPY_VALUE(retval, z);
			zendi_zval_copy_ctor(*retval);
			ALLOC_ZVAL(z_copy);
			INIT_PZVAL_COPY(z_copy, z);
			zendi_zval_copy_ctor(*z_copy);
			incdec_op(z_copy);
			Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, z_copy, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(&z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3374: /*ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER*/
{
	incdec_op = increment_function; goto zend_post_incdec_property_helper_SPEC_CV_CV;
}

case 3399: /*ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER*/
{
	incdec_op = decrement_function; goto zend_post_incdec_property_helper_SPEC_CV_CV;
}

case 2049: /*ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval **container;

	SAVE_OPLINE();

	if ((opline->extended_value & ZEND_FETCH_ADD_LOCK) &&
	    IS_CV != IS_CV &&
	    EX_T(opline->op1.var).var.ptr_ptr) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
	}

	if (IS_CV == IS_TMP_VAR || IS_CV == IS_CONST) {
		zval *container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), &container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);


	} else {
		container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);


	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2124: /*ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_W TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (UNEXPECTED(opline->extended_value != 0)) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		if (retval_ptr) {
			Z_DELREF_PP(retval_ptr);
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			Z_ADDREF_PP(retval_ptr);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2199: /*ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_RW TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2274: /*ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_IS TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2349: /*ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_W TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}
	} else {
		if (IS_CV == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_R TSRMLS_CC);
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2424: /*ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval **container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address(&EX_T(opline->result.var), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV, BP_VAR_UNSET TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	if (UNEXPECTED(EX_T(opline->result.var).var.ptr_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_res;
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		PZVAL_UNLOCK(*retval_ptr, &free_res);
		if (retval_ptr != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(retval_ptr);
		}
		PZVAL_LOCK(*retval_ptr);
		FREE_OP_VAR_PTR(free_res);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

zend_fetch_property_address_read_helper_SPEC_CV_CV:
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2074: /*ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER*/
{
	goto zend_fetch_property_address_read_helper_SPEC_CV_CV;
}

case 2149: /*ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_VAR && (opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		PZVAL_LOCK(*EX_T(opline->op1.var).var.ptr_ptr);
		EX_T(opline->op1.var).var.ptr = *EX_T(opline->op1.var).var.ptr_ptr;
	}

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	/* We are going to assign the result by reference */
	if (opline->extended_value & ZEND_FETCH_MAKE_REF) {
		zval **retval_ptr = EX_T(opline->result.var).var.ptr_ptr;

		Z_DELREF_PP(retval_ptr);
		SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
		Z_ADDREF_PP(retval_ptr);
		EX_T(opline->result.var).var.ptr = *EX_T(opline->result.var).var.ptr_ptr;
		EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2224: /*ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval **container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_RW TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2299: /*ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		PZVAL_LOCK(&EG(uninitialized_zval));
		AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	} else {
		zval *retval;

		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);

		PZVAL_LOCK(retval);
		AI_SET_PTR(&EX_T(opline->result.var), retval);

		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2374: /*ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, (opline->extended_value & ZEND_FETCH_ARG_MASK))) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;
		zval **container;

		SAVE_OPLINE();
		property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property);
		}
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_W TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property);
		} else {

		}
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		goto zend_fetch_property_address_read_helper_SPEC_CV_CV;
	}
}

case 2449: /*ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op1, free_res;
	zval **container;
	zval *property;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_CV) {
		if (container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
	}
	if (0) {
		MAKE_REAL_ZVAL_PTR(property);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(&EX_T(opline->result.var), container, property, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL), BP_VAR_UNSET TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property);
	} else {

	}
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(&EX_T(opline->result.var));
	}

	PZVAL_UNLOCK(*EX_T(opline->result.var).var.ptr_ptr, &free_res);
	if (EX_T(opline->result.var).var.ptr_ptr != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(EX_T(opline->result.var).var.ptr_ptr);
	}
	PZVAL_LOCK(*EX_T(opline->result.var).var.ptr_ptr);
	FREE_OP_VAR_PTR(free_res);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 3424: /*ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval **object_ptr;
	zval *property_name;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (0) {
		MAKE_REAL_ZVAL_PTR(property_name);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
	if (0) {
		zval_ptr_dtor(&property_name);
	} else {

	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 3699: /*ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval **object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(object_ptr == NULL)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (Z_TYPE_PP(object_ptr) == IS_OBJECT) {

		zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		if (0) {
			MAKE_REAL_ZVAL_PTR(property_name);
		}
		zend_assign_to_object(RETURN_VALUE_USED(opline)?&EX_T(opline->result.var).var.ptr:NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
		if (0) {
			zval_ptr_dtor(&property_name);
		} else {

		}
	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		zval **variable_ptr_ptr;

		zend_fetch_dimension_address(&EX_T((opline+1)->op2.var), object_ptr, dim, IS_CV, BP_VAR_W TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(variable_ptr_ptr == NULL)) {
			if (zend_assign_to_string_offset(&EX_T((opline+1)->op2.var), value, (opline+1)->op1_type TSRMLS_CC)) {
				if (RETURN_VALUE_USED(opline)) {
					zval *retval;

					ALLOC_ZVAL(retval);
					ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T((opline+1)->op2.var).str_offset.str)+EX_T((opline+1)->op2.var).str_offset.offset, 1, 1);
					INIT_PZVAL(retval);
					AI_SET_PTR(&EX_T(opline->result.var), retval);
				}
			} else if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else if (UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(&EG(uninitialized_zval));
				AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
			}
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				PZVAL_LOCK(value);
				AI_SET_PTR(&EX_T(opline->result.var), value);
			}
		}
		FREE_OP_VAR_PTR(free_op_data2);
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

case 974: /*ZEND_ASSIGN_SPEC_CV_CV_HANDLER*/ ZEND_ASSIGN_SPEC_CV_CV_LABEL:
{
	USE_OPLINE

	zval *value;
	zval **variable_ptr_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL)) {
		if (zend_assign_to_string_offset(&EX_T(opline->op1.var), value, IS_CV TSRMLS_CC)) {
			if (RETURN_VALUE_USED(opline)) {
				zval *retval;

				ALLOC_ZVAL(retval);
				ZVAL_STRINGL(retval, Z_STRVAL_P(EX_T(opline->op1.var).str_offset.str)+EX_T(opline->op1.var).str_offset.offset, 1, 1);
				INIT_PZVAL(retval);
				AI_SET_PTR(&EX_T(opline->result.var), retval);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else if (IS_CV == IS_VAR && UNEXPECTED(*variable_ptr_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(&EG(uninitialized_zval));
			AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));
		}
	} else {
		if (IS_CV == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else if (IS_CV == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			PZVAL_LOCK(value);
			AI_SET_PTR(&EX_T(opline->result.var), value);
		}
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 999: /*ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE
	zend_free_op free_op2;
	zval **variable_ptr_ptr;
	zval **value_ptr_ptr;

	SAVE_OPLINE();
	value_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_VAR &&
	    value_ptr_ptr &&
	    !Z_ISREF_PP(value_ptr_ptr) &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !EX_T(opline->op2.var).var.fcall_returned_reference) {
		if (free_op2.var == NULL) {
			PZVAL_LOCK(*value_ptr_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		goto ZEND_ASSIGN_SPEC_CV_CV_LABEL;
	} else if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		PZVAL_LOCK(*value_ptr_ptr);
	}
	if (IS_CV == IS_VAR && UNEXPECTED(EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr)) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}

	variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if ((IS_CV == IS_VAR && UNEXPECTED(value_ptr_ptr == NULL)) ||
	    (IS_CV == IS_VAR && UNEXPECTED(variable_ptr_ptr == NULL))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr TSRMLS_CC);

	if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		Z_DELREF_PP(variable_ptr_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		PZVAL_LOCK(*variable_ptr_ptr);
		AI_SET_PTR(&EX_T(opline->result.var), *variable_ptr_ptr);
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2824: /*ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE
	zval *function_name;
	char *function_name_strval;
	int function_name_strlen;

	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	function_name_strval = Z_STRVAL_P(function_name);
	function_name_strlen = Z_STRLEN_P(function_name);

	call->object = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (EXPECTED(call->object != NULL) &&
	    EXPECTED(Z_TYPE_P(call->object) == IS_OBJECT)) {
		call->called_scope = Z_OBJCE_P(call->object);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope)) == NULL) {
		    zval *object = call->object;

			if (UNEXPECTED(Z_OBJ_HT_P(call->object)->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = Z_OBJ_HT_P(call->object)->get_method(&call->object, function_name_strval, function_name_strlen, ((IS_CV == IS_CONST) ? (opline->op2.literal + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), function_name_strval);
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(opline->op2.literal->cache_slot, call->called_scope, call->fbc);
			}
		}
	} else {
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", function_name_strval);
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		if (!PZVAL_IS_REF(call->object)) {
			Z_ADDREF_P(call->object); /* For $this pointer */
		} else {
			zval *this_ptr;
			ALLOC_ZVAL(this_ptr);
			INIT_PZVAL_COPY(this_ptr, call->object);
			zval_copy_ctor(this_ptr);
			call->object = this_ptr;
		}
	}
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1224: /*ZEND_CASE_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE


	SAVE_OPLINE();
	if (IS_CV==IS_VAR) {
		PZVAL_LOCK(EX_T(opline->op1.var).var.ptr);
	}
	is_equal_function(&EX_T(opline->result.var).tmp_var,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1824: /*ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER*/ ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_LABEL:
{
	USE_OPLINE

	zval *expr_ptr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(expr_ptr_ptr == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr_ptr);
		expr_ptr = *expr_ptr_ptr;
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
		} else if (IS_CV == IS_CONST || PZVAL_IS_REF(expr_ptr)) {
			zval *new_expr;

			ALLOC_ZVAL(new_expr);
			INIT_PZVAL_COPY(new_expr, expr_ptr);
			expr_ptr = new_expr;
			zendi_zval_copy_ctor(*expr_ptr);
		} else {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_SPEC_CV_CV;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index_SPEC_CV_CV:
				zend_hash_index_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_SPEC_CV_CV);
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				zend_hash_quick_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, &expr_ptr, sizeof(zval *), NULL);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL(EX_T(opline->result.var).tmp_var), "", sizeof(""), &expr_ptr, sizeof(zval *), NULL);
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(&expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL(EX_T(opline->result.var).tmp_var), &expr_ptr, sizeof(zval *), NULL);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	} else {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1799: /*ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	array_init(&EX_T(opline->result.var).tmp_var);
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		goto ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_LABEL;
#endif
	}
}

case 1899: /*ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval **container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		switch (Z_TYPE_PP(container)) {
			case IS_ARRAY: {
				HashTable *ht = Z_ARRVAL_PP(container);

				switch (Z_TYPE_P(offset)) {
					case IS_DOUBLE:
						hval = zend_dval_to_lval(Z_DVAL_P(offset));
						zend_hash_index_del(ht, hval);
						break;
					case IS_RESOURCE:
					case IS_BOOL:
					case IS_LONG:
						hval = Z_LVAL_P(offset);
						zend_hash_index_del(ht, hval);
						break;
					case IS_STRING:
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							Z_ADDREF_P(offset);
						}
						if (IS_CV == IS_CONST) {
							hval = Z_HASH_P(offset);
						} else {
							ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim_SPEC_CV_CV);
							if (IS_INTERNED(Z_STRVAL_P(offset))) {
								hval = INTERNED_HASH(Z_STRVAL_P(offset));
							} else {
								hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
							}
						}
						if (ht == &EG(symbol_table)) {
							zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval TSRMLS_CC);
						} else {
							zend_hash_quick_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval);
						}
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
num_index_dim_SPEC_CV_CV:
						zend_hash_index_del(ht, hval);
						if (IS_CV == IS_CV || IS_CV == IS_VAR) {
							zval_ptr_dtor(&offset);
						}
						break;
					case IS_NULL:
						zend_hash_del(ht, "", sizeof(""));
						break;
					default:
						zend_error(E_WARNING, "Illegal offset type in unset");
						break;
				}

				break;
			}
			case IS_OBJECT:
				if (UNEXPECTED(Z_OBJ_HT_P(*container)->unset_dimension == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot use object as array");
				}
				if (0) {
					MAKE_REAL_ZVAL_PTR(offset);
				}
				Z_OBJ_HT_P(*container)->unset_dimension(*container, offset TSRMLS_CC);
				if (0) {
					zval_ptr_dtor(&offset);
				} else {

				}
				break;
			case IS_STRING:
				zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
				ZEND_VM_CONTINUE(); /* bailed out before */
			default:

				break;
		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 1924: /*ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	zval **container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_VAR || container) {
		if (IS_CV == IS_CV && container != &EG(uninitialized_zval_ptr)) {
			SEPARATE_ZVAL_IF_NOT_REF(container);
		}
		if (Z_TYPE_PP(container) == IS_OBJECT) {
			if (0) {
				MAKE_REAL_ZVAL_PTR(offset);
			}
			if (Z_OBJ_HT_P(*container)->unset_property) {
				Z_OBJ_HT_P(*container)->unset_property(*container, offset, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to unset property of non-object");
			}
			if (0) {
				zval_ptr_dtor(&offset);
			} else {

			}
		} else {

		}
	} else {

	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV:
{
	USE_OPLINE

	zval **container;
	zval **value = NULL;
	int result = 0;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (Z_TYPE_PP(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht;
		int isset = 0;

		ht = Z_ARRVAL_PP(container);

		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop_SPEC_CV_CV;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop_SPEC_CV_CV:
				if (zend_hash_index_find(ht, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_STRING:
				if (IS_CV == IS_CONST) {
					hval = Z_HASH_P(offset);
				} else {
					if (!prop_dim) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_prop_SPEC_CV_CV);
					}
					if (IS_INTERNED(Z_STRVAL_P(offset))) {
						hval = INTERNED_HASH(Z_STRVAL_P(offset));
					} else {
						hval = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
					}
				}
				if (zend_hash_quick_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			case IS_NULL:
				if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == SUCCESS) {
					isset = 1;
				}
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			if (isset && Z_TYPE_PP(value) == IS_NULL) {
				result = 0;
			} else {
				result = isset;
			}
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			if (!isset || !i_zend_is_true(*value)) {
				result = 0;
			} else {
				result = 1;
			}
		}

	} else if (Z_TYPE_PP(container) == IS_OBJECT) {
		if (0) {
			MAKE_REAL_ZVAL_PTR(offset);
		}
		if (prop_dim) {
			if (Z_OBJ_HT_P(*container)->has_property) {
				result = Z_OBJ_HT_P(*container)->has_property(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0, ((IS_CV == IS_CONST) ? opline->op2.literal : NULL) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(*container)->has_dimension) {
				result = Z_OBJ_HT_P(*container)->has_dimension(*container, offset, (opline->extended_value & ZEND_ISEMPTY) != 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if (0) {
			zval_ptr_dtor(&offset);
		} else {

		}
	} else if ((*container)->type == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		if (Z_TYPE_P(offset) != IS_LONG) {
			if (Z_TYPE_P(offset) <= IS_BOOL /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_COPY_VALUE(&tmp, offset);
				zval_copy_ctor(&tmp);
				convert_to_long(&tmp);
				offset = &tmp;
			} else {
				/* can not be converted to proper offset, return "not set" */
				result = 0;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (opline->extended_value & ZEND_ISSET) {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container)) {
					result = 1;
				}
			} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
				if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}

	} else {

	}

	Z_TYPE(EX_T(opline->result.var).tmp_var) = IS_BOOL;
	if (opline->extended_value & ZEND_ISSET) {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = result;
	} else {
		Z_LVAL(EX_T(opline->result.var).tmp_var) = !result;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

case 2899: /*ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER*/
{
	prop_dim = 0; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV;
}

case 3724: /*ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER*/
{
	prop_dim = 1; goto zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV;
}

case 4024: /*ZEND_YIELD_SPEC_CV_CV_HANDLER*/
{
	USE_OPLINE

	/* The generator object is stored in return_value_ptr_ptr */
	zend_generator *generator = (zend_generator *) EG(return_value_ptr_ptr);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	if (generator->value) {
		zval_ptr_dtor(&generator->value);
	}

	/* Destroy the previously yielded key */
	if (generator->key) {
		zval_ptr_dtor(&generator->key);
	}

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value, *copy;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				zval **value_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(value_ptr == NULL)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_PP(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && EX_T(opline->op1.var).var.fcall_returned_reference)
				    && EX_T(opline->op1.var).var.ptr_ptr == &EX_T(opline->op1.var).var.ptr) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");

					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
					Z_ADDREF_PP(value_ptr);
					generator->value = *value_ptr;
				}

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
				|| (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) > 0)
			) {
				zval *copy;

				ALLOC_ZVAL(copy);
				INIT_PZVAL_COPY(copy, value);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(copy);
				}

				generator->value = copy;
			} else {
				Z_ADDREF_P(value);
				generator->value = value;
			}

		}
	} else {
		/* If no value was specified yield null */
		Z_ADDREF(EG(uninitialized_zval));
		generator->value = &EG(uninitialized_zval);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR
			|| (PZVAL_IS_REF(key) && Z_REFCOUNT_P(key) > 0)
		) {
			zval *copy;

			ALLOC_ZVAL(copy);
			INIT_PZVAL_COPY(copy, key);

			/* Temporary variables don't need ctor copying */
			if (!0) {
				zval_copy_ctor(copy);
			}

			generator->key = copy;
		} else {
			Z_ADDREF_P(key);
			generator->key = key;
		}

		if (Z_TYPE_P(generator->key) == IS_LONG
		    && Z_LVAL_P(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL_P(generator->key);
		}

	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;

		ALLOC_INIT_ZVAL(generator->key);
		ZVAL_LONG(generator->key, generator->largest_used_integer_key);
	}

	/* If a value is sent it should go into the result var */
	generator->send_target = &EX_T(opline->result.var);

	/* Initialize the sent value to NULL */
	Z_ADDREF(EG(uninitialized_zval));
	AI_SET_PTR(&EX_T(opline->result.var), &EG(uninitialized_zval));

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

default:
	zend_error_noreturn(E_ERROR, "Invalid opcode %d/%d/%d.", OPLINE->opcode, OPLINE->op1_type, OPLINE->op2_type);
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}

	}
	zend_error_noreturn(E_ERROR, "Arrived at end of main loop which shouldn't happen");
}

ZEND_API void zend_execute(zend_op_array *op_array TSRMLS_DC)
{
	if (EG(exception)) {
		return;
	} 
	zend_execute_ex(i_create_execute_data_from_op_array(op_array, 0 TSRMLS_CC) TSRMLS_CC);
}


void zend_init_opcodes_handlers(void)
{
  static const opcode_handler_t labels[] = {
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)0,
  	(opcode_handler_t)25,
  	(opcode_handler_t)26,
  	(opcode_handler_t)27,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)29,
  	(opcode_handler_t)30,
  	(opcode_handler_t)31,
  	(opcode_handler_t)32,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)34,
  	(opcode_handler_t)35,
  	(opcode_handler_t)36,
  	(opcode_handler_t)37,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)39,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)45,
  	(opcode_handler_t)46,
  	(opcode_handler_t)47,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)49,
  	(opcode_handler_t)50,
  	(opcode_handler_t)51,
  	(opcode_handler_t)52,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)54,
  	(opcode_handler_t)55,
  	(opcode_handler_t)56,
  	(opcode_handler_t)57,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)59,
  	(opcode_handler_t)60,
  	(opcode_handler_t)61,
  	(opcode_handler_t)62,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)64,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)70,
  	(opcode_handler_t)71,
  	(opcode_handler_t)72,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)74,
  	(opcode_handler_t)75,
  	(opcode_handler_t)76,
  	(opcode_handler_t)77,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)79,
  	(opcode_handler_t)80,
  	(opcode_handler_t)81,
  	(opcode_handler_t)82,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)84,
  	(opcode_handler_t)85,
  	(opcode_handler_t)86,
  	(opcode_handler_t)87,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)89,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)95,
  	(opcode_handler_t)96,
  	(opcode_handler_t)97,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)99,
  	(opcode_handler_t)100,
  	(opcode_handler_t)101,
  	(opcode_handler_t)102,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)104,
  	(opcode_handler_t)105,
  	(opcode_handler_t)106,
  	(opcode_handler_t)107,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)109,
  	(opcode_handler_t)110,
  	(opcode_handler_t)111,
  	(opcode_handler_t)112,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)114,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)120,
  	(opcode_handler_t)121,
  	(opcode_handler_t)122,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)124,
  	(opcode_handler_t)125,
  	(opcode_handler_t)126,
  	(opcode_handler_t)127,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)129,
  	(opcode_handler_t)130,
  	(opcode_handler_t)131,
  	(opcode_handler_t)132,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)134,
  	(opcode_handler_t)135,
  	(opcode_handler_t)136,
  	(opcode_handler_t)137,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)139,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)145,
  	(opcode_handler_t)146,
  	(opcode_handler_t)147,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)149,
  	(opcode_handler_t)150,
  	(opcode_handler_t)151,
  	(opcode_handler_t)152,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)154,
  	(opcode_handler_t)155,
  	(opcode_handler_t)156,
  	(opcode_handler_t)157,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)159,
  	(opcode_handler_t)160,
  	(opcode_handler_t)161,
  	(opcode_handler_t)162,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)164,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)170,
  	(opcode_handler_t)171,
  	(opcode_handler_t)172,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)174,
  	(opcode_handler_t)175,
  	(opcode_handler_t)176,
  	(opcode_handler_t)177,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)179,
  	(opcode_handler_t)180,
  	(opcode_handler_t)181,
  	(opcode_handler_t)182,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)184,
  	(opcode_handler_t)185,
  	(opcode_handler_t)186,
  	(opcode_handler_t)187,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)189,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)195,
  	(opcode_handler_t)196,
  	(opcode_handler_t)197,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)199,
  	(opcode_handler_t)200,
  	(opcode_handler_t)201,
  	(opcode_handler_t)202,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)204,
  	(opcode_handler_t)205,
  	(opcode_handler_t)206,
  	(opcode_handler_t)207,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)209,
  	(opcode_handler_t)210,
  	(opcode_handler_t)211,
  	(opcode_handler_t)212,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)214,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)220,
  	(opcode_handler_t)221,
  	(opcode_handler_t)222,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)224,
  	(opcode_handler_t)225,
  	(opcode_handler_t)226,
  	(opcode_handler_t)227,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)229,
  	(opcode_handler_t)230,
  	(opcode_handler_t)231,
  	(opcode_handler_t)232,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)234,
  	(opcode_handler_t)235,
  	(opcode_handler_t)236,
  	(opcode_handler_t)237,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)239,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)245,
  	(opcode_handler_t)246,
  	(opcode_handler_t)247,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)249,
  	(opcode_handler_t)250,
  	(opcode_handler_t)251,
  	(opcode_handler_t)252,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)254,
  	(opcode_handler_t)255,
  	(opcode_handler_t)256,
  	(opcode_handler_t)257,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)259,
  	(opcode_handler_t)260,
  	(opcode_handler_t)261,
  	(opcode_handler_t)262,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)264,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)270,
  	(opcode_handler_t)271,
  	(opcode_handler_t)272,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)274,
  	(opcode_handler_t)275,
  	(opcode_handler_t)276,
  	(opcode_handler_t)277,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)279,
  	(opcode_handler_t)280,
  	(opcode_handler_t)281,
  	(opcode_handler_t)282,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)284,
  	(opcode_handler_t)285,
  	(opcode_handler_t)286,
  	(opcode_handler_t)287,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)289,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)295,
  	(opcode_handler_t)296,
  	(opcode_handler_t)297,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)299,
  	(opcode_handler_t)300,
  	(opcode_handler_t)300,
  	(opcode_handler_t)300,
  	(opcode_handler_t)300,
  	(opcode_handler_t)300,
  	(opcode_handler_t)305,
  	(opcode_handler_t)305,
  	(opcode_handler_t)305,
  	(opcode_handler_t)305,
  	(opcode_handler_t)305,
  	(opcode_handler_t)310,
  	(opcode_handler_t)310,
  	(opcode_handler_t)310,
  	(opcode_handler_t)310,
  	(opcode_handler_t)310,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)320,
  	(opcode_handler_t)320,
  	(opcode_handler_t)320,
  	(opcode_handler_t)320,
  	(opcode_handler_t)320,
  	(opcode_handler_t)325,
  	(opcode_handler_t)325,
  	(opcode_handler_t)325,
  	(opcode_handler_t)325,
  	(opcode_handler_t)325,
  	(opcode_handler_t)330,
  	(opcode_handler_t)330,
  	(opcode_handler_t)330,
  	(opcode_handler_t)330,
  	(opcode_handler_t)330,
  	(opcode_handler_t)335,
  	(opcode_handler_t)335,
  	(opcode_handler_t)335,
  	(opcode_handler_t)335,
  	(opcode_handler_t)335,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)345,
  	(opcode_handler_t)345,
  	(opcode_handler_t)345,
  	(opcode_handler_t)345,
  	(opcode_handler_t)345,
  	(opcode_handler_t)350,
  	(opcode_handler_t)351,
  	(opcode_handler_t)352,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)354,
  	(opcode_handler_t)355,
  	(opcode_handler_t)356,
  	(opcode_handler_t)357,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)359,
  	(opcode_handler_t)360,
  	(opcode_handler_t)361,
  	(opcode_handler_t)362,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)364,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)370,
  	(opcode_handler_t)371,
  	(opcode_handler_t)372,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)374,
  	(opcode_handler_t)375,
  	(opcode_handler_t)376,
  	(opcode_handler_t)377,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)379,
  	(opcode_handler_t)380,
  	(opcode_handler_t)381,
  	(opcode_handler_t)382,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)384,
  	(opcode_handler_t)385,
  	(opcode_handler_t)386,
  	(opcode_handler_t)387,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)389,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)395,
  	(opcode_handler_t)396,
  	(opcode_handler_t)397,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)399,
  	(opcode_handler_t)400,
  	(opcode_handler_t)401,
  	(opcode_handler_t)402,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)404,
  	(opcode_handler_t)405,
  	(opcode_handler_t)406,
  	(opcode_handler_t)407,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)409,
  	(opcode_handler_t)410,
  	(opcode_handler_t)411,
  	(opcode_handler_t)412,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)414,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)420,
  	(opcode_handler_t)421,
  	(opcode_handler_t)422,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)424,
  	(opcode_handler_t)425,
  	(opcode_handler_t)426,
  	(opcode_handler_t)427,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)429,
  	(opcode_handler_t)430,
  	(opcode_handler_t)431,
  	(opcode_handler_t)432,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)434,
  	(opcode_handler_t)435,
  	(opcode_handler_t)436,
  	(opcode_handler_t)437,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)439,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)445,
  	(opcode_handler_t)446,
  	(opcode_handler_t)447,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)449,
  	(opcode_handler_t)450,
  	(opcode_handler_t)451,
  	(opcode_handler_t)452,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)454,
  	(opcode_handler_t)455,
  	(opcode_handler_t)456,
  	(opcode_handler_t)457,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)459,
  	(opcode_handler_t)460,
  	(opcode_handler_t)461,
  	(opcode_handler_t)462,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)464,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)470,
  	(opcode_handler_t)471,
  	(opcode_handler_t)472,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)474,
  	(opcode_handler_t)475,
  	(opcode_handler_t)476,
  	(opcode_handler_t)477,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)479,
  	(opcode_handler_t)480,
  	(opcode_handler_t)481,
  	(opcode_handler_t)482,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)484,
  	(opcode_handler_t)485,
  	(opcode_handler_t)486,
  	(opcode_handler_t)487,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)489,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)495,
  	(opcode_handler_t)496,
  	(opcode_handler_t)497,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)499,
  	(opcode_handler_t)500,
  	(opcode_handler_t)501,
  	(opcode_handler_t)502,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)504,
  	(opcode_handler_t)505,
  	(opcode_handler_t)506,
  	(opcode_handler_t)507,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)509,
  	(opcode_handler_t)510,
  	(opcode_handler_t)511,
  	(opcode_handler_t)512,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)514,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)520,
  	(opcode_handler_t)521,
  	(opcode_handler_t)522,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)524,
  	(opcode_handler_t)525,
  	(opcode_handler_t)525,
  	(opcode_handler_t)525,
  	(opcode_handler_t)525,
  	(opcode_handler_t)525,
  	(opcode_handler_t)530,
  	(opcode_handler_t)530,
  	(opcode_handler_t)530,
  	(opcode_handler_t)530,
  	(opcode_handler_t)530,
  	(opcode_handler_t)535,
  	(opcode_handler_t)535,
  	(opcode_handler_t)535,
  	(opcode_handler_t)535,
  	(opcode_handler_t)535,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)545,
  	(opcode_handler_t)545,
  	(opcode_handler_t)545,
  	(opcode_handler_t)545,
  	(opcode_handler_t)545,
  	(opcode_handler_t)550,
  	(opcode_handler_t)550,
  	(opcode_handler_t)550,
  	(opcode_handler_t)550,
  	(opcode_handler_t)550,
  	(opcode_handler_t)555,
  	(opcode_handler_t)555,
  	(opcode_handler_t)555,
  	(opcode_handler_t)555,
  	(opcode_handler_t)555,
  	(opcode_handler_t)560,
  	(opcode_handler_t)560,
  	(opcode_handler_t)560,
  	(opcode_handler_t)560,
  	(opcode_handler_t)560,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)570,
  	(opcode_handler_t)570,
  	(opcode_handler_t)570,
  	(opcode_handler_t)570,
  	(opcode_handler_t)570,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)585,
  	(opcode_handler_t)586,
  	(opcode_handler_t)587,
  	(opcode_handler_t)588,
  	(opcode_handler_t)589,
  	(opcode_handler_t)590,
  	(opcode_handler_t)591,
  	(opcode_handler_t)592,
  	(opcode_handler_t)593,
  	(opcode_handler_t)594,
  	(opcode_handler_t)595,
  	(opcode_handler_t)596,
  	(opcode_handler_t)597,
  	(opcode_handler_t)598,
  	(opcode_handler_t)599,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)610,
  	(opcode_handler_t)611,
  	(opcode_handler_t)612,
  	(opcode_handler_t)613,
  	(opcode_handler_t)614,
  	(opcode_handler_t)615,
  	(opcode_handler_t)616,
  	(opcode_handler_t)617,
  	(opcode_handler_t)618,
  	(opcode_handler_t)619,
  	(opcode_handler_t)620,
  	(opcode_handler_t)621,
  	(opcode_handler_t)622,
  	(opcode_handler_t)623,
  	(opcode_handler_t)624,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)635,
  	(opcode_handler_t)636,
  	(opcode_handler_t)637,
  	(opcode_handler_t)638,
  	(opcode_handler_t)639,
  	(opcode_handler_t)640,
  	(opcode_handler_t)641,
  	(opcode_handler_t)642,
  	(opcode_handler_t)643,
  	(opcode_handler_t)644,
  	(opcode_handler_t)645,
  	(opcode_handler_t)646,
  	(opcode_handler_t)647,
  	(opcode_handler_t)648,
  	(opcode_handler_t)649,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)660,
  	(opcode_handler_t)661,
  	(opcode_handler_t)662,
  	(opcode_handler_t)663,
  	(opcode_handler_t)664,
  	(opcode_handler_t)665,
  	(opcode_handler_t)666,
  	(opcode_handler_t)667,
  	(opcode_handler_t)668,
  	(opcode_handler_t)669,
  	(opcode_handler_t)670,
  	(opcode_handler_t)671,
  	(opcode_handler_t)672,
  	(opcode_handler_t)673,
  	(opcode_handler_t)674,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)685,
  	(opcode_handler_t)686,
  	(opcode_handler_t)687,
  	(opcode_handler_t)688,
  	(opcode_handler_t)689,
  	(opcode_handler_t)690,
  	(opcode_handler_t)691,
  	(opcode_handler_t)692,
  	(opcode_handler_t)693,
  	(opcode_handler_t)694,
  	(opcode_handler_t)695,
  	(opcode_handler_t)696,
  	(opcode_handler_t)697,
  	(opcode_handler_t)698,
  	(opcode_handler_t)699,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)710,
  	(opcode_handler_t)711,
  	(opcode_handler_t)712,
  	(opcode_handler_t)713,
  	(opcode_handler_t)714,
  	(opcode_handler_t)715,
  	(opcode_handler_t)716,
  	(opcode_handler_t)717,
  	(opcode_handler_t)718,
  	(opcode_handler_t)719,
  	(opcode_handler_t)720,
  	(opcode_handler_t)721,
  	(opcode_handler_t)722,
  	(opcode_handler_t)723,
  	(opcode_handler_t)724,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)735,
  	(opcode_handler_t)736,
  	(opcode_handler_t)737,
  	(opcode_handler_t)738,
  	(opcode_handler_t)739,
  	(opcode_handler_t)740,
  	(opcode_handler_t)741,
  	(opcode_handler_t)742,
  	(opcode_handler_t)743,
  	(opcode_handler_t)744,
  	(opcode_handler_t)745,
  	(opcode_handler_t)746,
  	(opcode_handler_t)747,
  	(opcode_handler_t)748,
  	(opcode_handler_t)749,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)760,
  	(opcode_handler_t)761,
  	(opcode_handler_t)762,
  	(opcode_handler_t)763,
  	(opcode_handler_t)764,
  	(opcode_handler_t)765,
  	(opcode_handler_t)766,
  	(opcode_handler_t)767,
  	(opcode_handler_t)768,
  	(opcode_handler_t)769,
  	(opcode_handler_t)770,
  	(opcode_handler_t)771,
  	(opcode_handler_t)772,
  	(opcode_handler_t)773,
  	(opcode_handler_t)774,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)785,
  	(opcode_handler_t)786,
  	(opcode_handler_t)787,
  	(opcode_handler_t)788,
  	(opcode_handler_t)789,
  	(opcode_handler_t)790,
  	(opcode_handler_t)791,
  	(opcode_handler_t)792,
  	(opcode_handler_t)793,
  	(opcode_handler_t)794,
  	(opcode_handler_t)795,
  	(opcode_handler_t)796,
  	(opcode_handler_t)797,
  	(opcode_handler_t)798,
  	(opcode_handler_t)799,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)810,
  	(opcode_handler_t)811,
  	(opcode_handler_t)812,
  	(opcode_handler_t)813,
  	(opcode_handler_t)814,
  	(opcode_handler_t)815,
  	(opcode_handler_t)816,
  	(opcode_handler_t)817,
  	(opcode_handler_t)818,
  	(opcode_handler_t)819,
  	(opcode_handler_t)820,
  	(opcode_handler_t)821,
  	(opcode_handler_t)822,
  	(opcode_handler_t)823,
  	(opcode_handler_t)824,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)835,
  	(opcode_handler_t)836,
  	(opcode_handler_t)837,
  	(opcode_handler_t)838,
  	(opcode_handler_t)839,
  	(opcode_handler_t)840,
  	(opcode_handler_t)841,
  	(opcode_handler_t)842,
  	(opcode_handler_t)843,
  	(opcode_handler_t)844,
  	(opcode_handler_t)845,
  	(opcode_handler_t)846,
  	(opcode_handler_t)847,
  	(opcode_handler_t)848,
  	(opcode_handler_t)849,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)860,
  	(opcode_handler_t)860,
  	(opcode_handler_t)860,
  	(opcode_handler_t)860,
  	(opcode_handler_t)860,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)870,
  	(opcode_handler_t)870,
  	(opcode_handler_t)870,
  	(opcode_handler_t)870,
  	(opcode_handler_t)870,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)885,
  	(opcode_handler_t)885,
  	(opcode_handler_t)885,
  	(opcode_handler_t)885,
  	(opcode_handler_t)885,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)895,
  	(opcode_handler_t)895,
  	(opcode_handler_t)895,
  	(opcode_handler_t)895,
  	(opcode_handler_t)895,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)910,
  	(opcode_handler_t)910,
  	(opcode_handler_t)910,
  	(opcode_handler_t)910,
  	(opcode_handler_t)910,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)920,
  	(opcode_handler_t)920,
  	(opcode_handler_t)920,
  	(opcode_handler_t)920,
  	(opcode_handler_t)920,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)935,
  	(opcode_handler_t)935,
  	(opcode_handler_t)935,
  	(opcode_handler_t)935,
  	(opcode_handler_t)935,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)945,
  	(opcode_handler_t)945,
  	(opcode_handler_t)945,
  	(opcode_handler_t)945,
  	(opcode_handler_t)945,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)960,
  	(opcode_handler_t)961,
  	(opcode_handler_t)962,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)964,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)970,
  	(opcode_handler_t)971,
  	(opcode_handler_t)972,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)974,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)987,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)989,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)997,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)999,
  	(opcode_handler_t)1000,
  	(opcode_handler_t)1000,
  	(opcode_handler_t)1000,
  	(opcode_handler_t)1000,
  	(opcode_handler_t)1000,
  	(opcode_handler_t)1005,
  	(opcode_handler_t)1005,
  	(opcode_handler_t)1005,
  	(opcode_handler_t)1005,
  	(opcode_handler_t)1005,
  	(opcode_handler_t)1010,
  	(opcode_handler_t)1010,
  	(opcode_handler_t)1010,
  	(opcode_handler_t)1010,
  	(opcode_handler_t)1010,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1020,
  	(opcode_handler_t)1020,
  	(opcode_handler_t)1020,
  	(opcode_handler_t)1020,
  	(opcode_handler_t)1020,
  	(opcode_handler_t)1025,
  	(opcode_handler_t)1025,
  	(opcode_handler_t)1025,
  	(opcode_handler_t)1025,
  	(opcode_handler_t)1025,
  	(opcode_handler_t)1030,
  	(opcode_handler_t)1030,
  	(opcode_handler_t)1030,
  	(opcode_handler_t)1030,
  	(opcode_handler_t)1030,
  	(opcode_handler_t)1035,
  	(opcode_handler_t)1035,
  	(opcode_handler_t)1035,
  	(opcode_handler_t)1035,
  	(opcode_handler_t)1035,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1045,
  	(opcode_handler_t)1045,
  	(opcode_handler_t)1045,
  	(opcode_handler_t)1045,
  	(opcode_handler_t)1045,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1050,
  	(opcode_handler_t)1075,
  	(opcode_handler_t)1075,
  	(opcode_handler_t)1075,
  	(opcode_handler_t)1075,
  	(opcode_handler_t)1075,
  	(opcode_handler_t)1080,
  	(opcode_handler_t)1080,
  	(opcode_handler_t)1080,
  	(opcode_handler_t)1080,
  	(opcode_handler_t)1080,
  	(opcode_handler_t)1085,
  	(opcode_handler_t)1085,
  	(opcode_handler_t)1085,
  	(opcode_handler_t)1085,
  	(opcode_handler_t)1085,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1095,
  	(opcode_handler_t)1095,
  	(opcode_handler_t)1095,
  	(opcode_handler_t)1095,
  	(opcode_handler_t)1095,
  	(opcode_handler_t)1100,
  	(opcode_handler_t)1100,
  	(opcode_handler_t)1100,
  	(opcode_handler_t)1100,
  	(opcode_handler_t)1100,
  	(opcode_handler_t)1105,
  	(opcode_handler_t)1105,
  	(opcode_handler_t)1105,
  	(opcode_handler_t)1105,
  	(opcode_handler_t)1105,
  	(opcode_handler_t)1110,
  	(opcode_handler_t)1110,
  	(opcode_handler_t)1110,
  	(opcode_handler_t)1110,
  	(opcode_handler_t)1110,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1120,
  	(opcode_handler_t)1120,
  	(opcode_handler_t)1120,
  	(opcode_handler_t)1120,
  	(opcode_handler_t)1120,
  	(opcode_handler_t)1125,
  	(opcode_handler_t)1125,
  	(opcode_handler_t)1125,
  	(opcode_handler_t)1125,
  	(opcode_handler_t)1125,
  	(opcode_handler_t)1130,
  	(opcode_handler_t)1130,
  	(opcode_handler_t)1130,
  	(opcode_handler_t)1130,
  	(opcode_handler_t)1130,
  	(opcode_handler_t)1135,
  	(opcode_handler_t)1135,
  	(opcode_handler_t)1135,
  	(opcode_handler_t)1135,
  	(opcode_handler_t)1135,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1145,
  	(opcode_handler_t)1145,
  	(opcode_handler_t)1145,
  	(opcode_handler_t)1145,
  	(opcode_handler_t)1145,
  	(opcode_handler_t)1150,
  	(opcode_handler_t)1150,
  	(opcode_handler_t)1150,
  	(opcode_handler_t)1150,
  	(opcode_handler_t)1150,
  	(opcode_handler_t)1155,
  	(opcode_handler_t)1155,
  	(opcode_handler_t)1155,
  	(opcode_handler_t)1155,
  	(opcode_handler_t)1155,
  	(opcode_handler_t)1160,
  	(opcode_handler_t)1160,
  	(opcode_handler_t)1160,
  	(opcode_handler_t)1160,
  	(opcode_handler_t)1160,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1170,
  	(opcode_handler_t)1170,
  	(opcode_handler_t)1170,
  	(opcode_handler_t)1170,
  	(opcode_handler_t)1170,
  	(opcode_handler_t)1175,
  	(opcode_handler_t)1175,
  	(opcode_handler_t)1175,
  	(opcode_handler_t)1175,
  	(opcode_handler_t)1175,
  	(opcode_handler_t)1180,
  	(opcode_handler_t)1180,
  	(opcode_handler_t)1180,
  	(opcode_handler_t)1180,
  	(opcode_handler_t)1180,
  	(opcode_handler_t)1185,
  	(opcode_handler_t)1185,
  	(opcode_handler_t)1185,
  	(opcode_handler_t)1185,
  	(opcode_handler_t)1185,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1195,
  	(opcode_handler_t)1195,
  	(opcode_handler_t)1195,
  	(opcode_handler_t)1195,
  	(opcode_handler_t)1195,
  	(opcode_handler_t)1200,
  	(opcode_handler_t)1201,
  	(opcode_handler_t)1202,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1204,
  	(opcode_handler_t)1205,
  	(opcode_handler_t)1206,
  	(opcode_handler_t)1207,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1209,
  	(opcode_handler_t)1210,
  	(opcode_handler_t)1211,
  	(opcode_handler_t)1212,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1214,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1220,
  	(opcode_handler_t)1221,
  	(opcode_handler_t)1222,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1224,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1235,
  	(opcode_handler_t)1235,
  	(opcode_handler_t)1235,
  	(opcode_handler_t)1235,
  	(opcode_handler_t)1235,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1250,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1250,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1250,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1250,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1250,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1275,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1275,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1275,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1275,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1275,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1300,
  	(opcode_handler_t)1300,
  	(opcode_handler_t)1300,
  	(opcode_handler_t)1300,
  	(opcode_handler_t)1300,
  	(opcode_handler_t)1305,
  	(opcode_handler_t)1305,
  	(opcode_handler_t)1305,
  	(opcode_handler_t)1305,
  	(opcode_handler_t)1305,
  	(opcode_handler_t)1310,
  	(opcode_handler_t)1310,
  	(opcode_handler_t)1310,
  	(opcode_handler_t)1310,
  	(opcode_handler_t)1310,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1320,
  	(opcode_handler_t)1320,
  	(opcode_handler_t)1320,
  	(opcode_handler_t)1320,
  	(opcode_handler_t)1320,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)1325,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1355,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1365,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1380,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1390,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1406,
  	(opcode_handler_t)1407,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1409,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1416,
  	(opcode_handler_t)1417,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1419,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)1425,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1455,
  	(opcode_handler_t)1455,
  	(opcode_handler_t)1455,
  	(opcode_handler_t)1455,
  	(opcode_handler_t)1455,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1475,
  	(opcode_handler_t)1476,
  	(opcode_handler_t)1477,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1479,
  	(opcode_handler_t)1475,
  	(opcode_handler_t)1476,
  	(opcode_handler_t)1477,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1479,
  	(opcode_handler_t)1475,
  	(opcode_handler_t)1476,
  	(opcode_handler_t)1477,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1479,
  	(opcode_handler_t)1475,
  	(opcode_handler_t)1476,
  	(opcode_handler_t)1477,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1479,
  	(opcode_handler_t)1475,
  	(opcode_handler_t)1476,
  	(opcode_handler_t)1477,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1479,
  	(opcode_handler_t)1500,
  	(opcode_handler_t)1500,
  	(opcode_handler_t)1500,
  	(opcode_handler_t)1500,
  	(opcode_handler_t)1500,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1525,
  	(opcode_handler_t)1550,
  	(opcode_handler_t)1550,
  	(opcode_handler_t)1550,
  	(opcode_handler_t)1550,
  	(opcode_handler_t)1550,
  	(opcode_handler_t)1555,
  	(opcode_handler_t)1555,
  	(opcode_handler_t)1555,
  	(opcode_handler_t)1555,
  	(opcode_handler_t)1555,
  	(opcode_handler_t)1560,
  	(opcode_handler_t)1560,
  	(opcode_handler_t)1560,
  	(opcode_handler_t)1560,
  	(opcode_handler_t)1560,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1570,
  	(opcode_handler_t)1570,
  	(opcode_handler_t)1570,
  	(opcode_handler_t)1570,
  	(opcode_handler_t)1570,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1575,
  	(opcode_handler_t)1600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1625,
  	(opcode_handler_t)1625,
  	(opcode_handler_t)1625,
  	(opcode_handler_t)1625,
  	(opcode_handler_t)1625,
  	(opcode_handler_t)1630,
  	(opcode_handler_t)1630,
  	(opcode_handler_t)1630,
  	(opcode_handler_t)1630,
  	(opcode_handler_t)1630,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1660,
  	(opcode_handler_t)1660,
  	(opcode_handler_t)1660,
  	(opcode_handler_t)1660,
  	(opcode_handler_t)1660,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1670,
  	(opcode_handler_t)1670,
  	(opcode_handler_t)1670,
  	(opcode_handler_t)1670,
  	(opcode_handler_t)1670,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1685,
  	(opcode_handler_t)1685,
  	(opcode_handler_t)1685,
  	(opcode_handler_t)1685,
  	(opcode_handler_t)1685,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1695,
  	(opcode_handler_t)1695,
  	(opcode_handler_t)1695,
  	(opcode_handler_t)1695,
  	(opcode_handler_t)1695,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1700,
  	(opcode_handler_t)1725,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1725,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1725,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1725,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1725,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1755,
  	(opcode_handler_t)1755,
  	(opcode_handler_t)1755,
  	(opcode_handler_t)1755,
  	(opcode_handler_t)1755,
  	(opcode_handler_t)1760,
  	(opcode_handler_t)1760,
  	(opcode_handler_t)1760,
  	(opcode_handler_t)1760,
  	(opcode_handler_t)1760,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1775,
  	(opcode_handler_t)1776,
  	(opcode_handler_t)1777,
  	(opcode_handler_t)1778,
  	(opcode_handler_t)1779,
  	(opcode_handler_t)1780,
  	(opcode_handler_t)1781,
  	(opcode_handler_t)1782,
  	(opcode_handler_t)1783,
  	(opcode_handler_t)1784,
  	(opcode_handler_t)1785,
  	(opcode_handler_t)1786,
  	(opcode_handler_t)1787,
  	(opcode_handler_t)1788,
  	(opcode_handler_t)1789,
  	(opcode_handler_t)1790,
  	(opcode_handler_t)1791,
  	(opcode_handler_t)1792,
  	(opcode_handler_t)1793,
  	(opcode_handler_t)1794,
  	(opcode_handler_t)1795,
  	(opcode_handler_t)1796,
  	(opcode_handler_t)1797,
  	(opcode_handler_t)1798,
  	(opcode_handler_t)1799,
  	(opcode_handler_t)1800,
  	(opcode_handler_t)1801,
  	(opcode_handler_t)1802,
  	(opcode_handler_t)1803,
  	(opcode_handler_t)1804,
  	(opcode_handler_t)1805,
  	(opcode_handler_t)1806,
  	(opcode_handler_t)1807,
  	(opcode_handler_t)1808,
  	(opcode_handler_t)1809,
  	(opcode_handler_t)1810,
  	(opcode_handler_t)1811,
  	(opcode_handler_t)1812,
  	(opcode_handler_t)1813,
  	(opcode_handler_t)1814,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1820,
  	(opcode_handler_t)1821,
  	(opcode_handler_t)1822,
  	(opcode_handler_t)1823,
  	(opcode_handler_t)1824,
  	(opcode_handler_t)1825,
  	(opcode_handler_t)1825,
  	(opcode_handler_t)1825,
  	(opcode_handler_t)1825,
  	(opcode_handler_t)1825,
  	(opcode_handler_t)1830,
  	(opcode_handler_t)1830,
  	(opcode_handler_t)1830,
  	(opcode_handler_t)1830,
  	(opcode_handler_t)1830,
  	(opcode_handler_t)1835,
  	(opcode_handler_t)1835,
  	(opcode_handler_t)1835,
  	(opcode_handler_t)1835,
  	(opcode_handler_t)1835,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1845,
  	(opcode_handler_t)1845,
  	(opcode_handler_t)1845,
  	(opcode_handler_t)1845,
  	(opcode_handler_t)1845,
  	(opcode_handler_t)1850,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1852,
  	(opcode_handler_t)1853,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1855,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1857,
  	(opcode_handler_t)1858,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1860,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1862,
  	(opcode_handler_t)1863,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1870,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1872,
  	(opcode_handler_t)1873,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1885,
  	(opcode_handler_t)1886,
  	(opcode_handler_t)1887,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1889,
  	(opcode_handler_t)1890,
  	(opcode_handler_t)1891,
  	(opcode_handler_t)1892,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1894,
  	(opcode_handler_t)1895,
  	(opcode_handler_t)1896,
  	(opcode_handler_t)1897,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1899,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1910,
  	(opcode_handler_t)1911,
  	(opcode_handler_t)1912,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1914,
  	(opcode_handler_t)1915,
  	(opcode_handler_t)1916,
  	(opcode_handler_t)1917,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1919,
  	(opcode_handler_t)1920,
  	(opcode_handler_t)1921,
  	(opcode_handler_t)1922,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1924,
  	(opcode_handler_t)1925,
  	(opcode_handler_t)1925,
  	(opcode_handler_t)1925,
  	(opcode_handler_t)1925,
  	(opcode_handler_t)1925,
  	(opcode_handler_t)1930,
  	(opcode_handler_t)1930,
  	(opcode_handler_t)1930,
  	(opcode_handler_t)1930,
  	(opcode_handler_t)1930,
  	(opcode_handler_t)1935,
  	(opcode_handler_t)1935,
  	(opcode_handler_t)1935,
  	(opcode_handler_t)1935,
  	(opcode_handler_t)1935,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1945,
  	(opcode_handler_t)1945,
  	(opcode_handler_t)1945,
  	(opcode_handler_t)1945,
  	(opcode_handler_t)1945,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1960,
  	(opcode_handler_t)1960,
  	(opcode_handler_t)1960,
  	(opcode_handler_t)1960,
  	(opcode_handler_t)1960,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)1975,
  	(opcode_handler_t)1975,
  	(opcode_handler_t)1975,
  	(opcode_handler_t)1975,
  	(opcode_handler_t)1975,
  	(opcode_handler_t)1980,
  	(opcode_handler_t)1980,
  	(opcode_handler_t)1980,
  	(opcode_handler_t)1980,
  	(opcode_handler_t)1980,
  	(opcode_handler_t)1985,
  	(opcode_handler_t)1985,
  	(opcode_handler_t)1985,
  	(opcode_handler_t)1985,
  	(opcode_handler_t)1985,
  	(opcode_handler_t)1990,
  	(opcode_handler_t)1990,
  	(opcode_handler_t)1990,
  	(opcode_handler_t)1990,
  	(opcode_handler_t)1990,
  	(opcode_handler_t)1995,
  	(opcode_handler_t)1995,
  	(opcode_handler_t)1995,
  	(opcode_handler_t)1995,
  	(opcode_handler_t)1995,
  	(opcode_handler_t)2000,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2002,
  	(opcode_handler_t)2003,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2005,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2007,
  	(opcode_handler_t)2008,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2010,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2012,
  	(opcode_handler_t)2013,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2020,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2022,
  	(opcode_handler_t)2023,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2025,
  	(opcode_handler_t)2026,
  	(opcode_handler_t)2027,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2029,
  	(opcode_handler_t)2030,
  	(opcode_handler_t)2031,
  	(opcode_handler_t)2032,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2034,
  	(opcode_handler_t)2035,
  	(opcode_handler_t)2036,
  	(opcode_handler_t)2037,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2039,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2045,
  	(opcode_handler_t)2046,
  	(opcode_handler_t)2047,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2049,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2060,
  	(opcode_handler_t)2061,
  	(opcode_handler_t)2062,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2064,
  	(opcode_handler_t)2065,
  	(opcode_handler_t)2066,
  	(opcode_handler_t)2067,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2069,
  	(opcode_handler_t)2070,
  	(opcode_handler_t)2071,
  	(opcode_handler_t)2072,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2074,
  	(opcode_handler_t)2075,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2077,
  	(opcode_handler_t)2078,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2080,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2082,
  	(opcode_handler_t)2083,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2085,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2087,
  	(opcode_handler_t)2088,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2095,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2097,
  	(opcode_handler_t)2098,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2110,
  	(opcode_handler_t)2111,
  	(opcode_handler_t)2112,
  	(opcode_handler_t)2113,
  	(opcode_handler_t)2114,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2120,
  	(opcode_handler_t)2121,
  	(opcode_handler_t)2122,
  	(opcode_handler_t)2123,
  	(opcode_handler_t)2124,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2135,
  	(opcode_handler_t)2136,
  	(opcode_handler_t)2137,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2139,
  	(opcode_handler_t)2140,
  	(opcode_handler_t)2141,
  	(opcode_handler_t)2142,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2144,
  	(opcode_handler_t)2145,
  	(opcode_handler_t)2146,
  	(opcode_handler_t)2147,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2149,
  	(opcode_handler_t)2150,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2152,
  	(opcode_handler_t)2153,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2155,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2157,
  	(opcode_handler_t)2158,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2160,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2162,
  	(opcode_handler_t)2163,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2170,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2172,
  	(opcode_handler_t)2173,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2185,
  	(opcode_handler_t)2186,
  	(opcode_handler_t)2187,
  	(opcode_handler_t)2188,
  	(opcode_handler_t)2189,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2195,
  	(opcode_handler_t)2196,
  	(opcode_handler_t)2197,
  	(opcode_handler_t)2198,
  	(opcode_handler_t)2199,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2210,
  	(opcode_handler_t)2211,
  	(opcode_handler_t)2212,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2214,
  	(opcode_handler_t)2215,
  	(opcode_handler_t)2216,
  	(opcode_handler_t)2217,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2219,
  	(opcode_handler_t)2220,
  	(opcode_handler_t)2221,
  	(opcode_handler_t)2222,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2224,
  	(opcode_handler_t)2225,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2227,
  	(opcode_handler_t)2228,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2230,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2232,
  	(opcode_handler_t)2233,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2235,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2237,
  	(opcode_handler_t)2238,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2245,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2247,
  	(opcode_handler_t)2248,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2260,
  	(opcode_handler_t)2261,
  	(opcode_handler_t)2262,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2264,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2270,
  	(opcode_handler_t)2271,
  	(opcode_handler_t)2272,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2274,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2285,
  	(opcode_handler_t)2286,
  	(opcode_handler_t)2287,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2289,
  	(opcode_handler_t)2290,
  	(opcode_handler_t)2291,
  	(opcode_handler_t)2292,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2294,
  	(opcode_handler_t)2295,
  	(opcode_handler_t)2296,
  	(opcode_handler_t)2297,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2299,
  	(opcode_handler_t)2300,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2302,
  	(opcode_handler_t)2303,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2305,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2307,
  	(opcode_handler_t)2308,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2310,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2312,
  	(opcode_handler_t)2313,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2320,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2322,
  	(opcode_handler_t)2323,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2335,
  	(opcode_handler_t)2336,
  	(opcode_handler_t)2337,
  	(opcode_handler_t)2338,
  	(opcode_handler_t)2339,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2345,
  	(opcode_handler_t)2346,
  	(opcode_handler_t)2347,
  	(opcode_handler_t)2348,
  	(opcode_handler_t)2349,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2360,
  	(opcode_handler_t)2361,
  	(opcode_handler_t)2362,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2364,
  	(opcode_handler_t)2365,
  	(opcode_handler_t)2366,
  	(opcode_handler_t)2367,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2369,
  	(opcode_handler_t)2370,
  	(opcode_handler_t)2371,
  	(opcode_handler_t)2372,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2374,
  	(opcode_handler_t)2375,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2377,
  	(opcode_handler_t)2378,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2380,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2382,
  	(opcode_handler_t)2383,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2385,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2387,
  	(opcode_handler_t)2388,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2395,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2397,
  	(opcode_handler_t)2398,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2410,
  	(opcode_handler_t)2411,
  	(opcode_handler_t)2412,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2414,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2420,
  	(opcode_handler_t)2421,
  	(opcode_handler_t)2422,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2424,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2435,
  	(opcode_handler_t)2436,
  	(opcode_handler_t)2437,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2439,
  	(opcode_handler_t)2440,
  	(opcode_handler_t)2441,
  	(opcode_handler_t)2442,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2444,
  	(opcode_handler_t)2445,
  	(opcode_handler_t)2446,
  	(opcode_handler_t)2447,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2449,
  	(opcode_handler_t)2450,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2455,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2475,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2485,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2490,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2500,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2500,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2500,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2500,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2500,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2525,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2550,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2575,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2600,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)2625,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2660,
  	(opcode_handler_t)2660,
  	(opcode_handler_t)2660,
  	(opcode_handler_t)2660,
  	(opcode_handler_t)2660,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2670,
  	(opcode_handler_t)2670,
  	(opcode_handler_t)2670,
  	(opcode_handler_t)2670,
  	(opcode_handler_t)2670,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2679,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2700,
  	(opcode_handler_t)2700,
  	(opcode_handler_t)2700,
  	(opcode_handler_t)2700,
  	(opcode_handler_t)2700,
  	(opcode_handler_t)2705,
  	(opcode_handler_t)2705,
  	(opcode_handler_t)2705,
  	(opcode_handler_t)2705,
  	(opcode_handler_t)2705,
  	(opcode_handler_t)2710,
  	(opcode_handler_t)2710,
  	(opcode_handler_t)2710,
  	(opcode_handler_t)2710,
  	(opcode_handler_t)2710,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2720,
  	(opcode_handler_t)2720,
  	(opcode_handler_t)2720,
  	(opcode_handler_t)2720,
  	(opcode_handler_t)2720,
  	(opcode_handler_t)2725,
  	(opcode_handler_t)2726,
  	(opcode_handler_t)2727,
  	(opcode_handler_t)2728,
  	(opcode_handler_t)2729,
  	(opcode_handler_t)2725,
  	(opcode_handler_t)2726,
  	(opcode_handler_t)2727,
  	(opcode_handler_t)2728,
  	(opcode_handler_t)2729,
  	(opcode_handler_t)2725,
  	(opcode_handler_t)2726,
  	(opcode_handler_t)2727,
  	(opcode_handler_t)2728,
  	(opcode_handler_t)2729,
  	(opcode_handler_t)2725,
  	(opcode_handler_t)2726,
  	(opcode_handler_t)2727,
  	(opcode_handler_t)2728,
  	(opcode_handler_t)2729,
  	(opcode_handler_t)2725,
  	(opcode_handler_t)2726,
  	(opcode_handler_t)2727,
  	(opcode_handler_t)2728,
  	(opcode_handler_t)2729,
  	(opcode_handler_t)2750,
  	(opcode_handler_t)2750,
  	(opcode_handler_t)2750,
  	(opcode_handler_t)2750,
  	(opcode_handler_t)2750,
  	(opcode_handler_t)2755,
  	(opcode_handler_t)2755,
  	(opcode_handler_t)2755,
  	(opcode_handler_t)2755,
  	(opcode_handler_t)2755,
  	(opcode_handler_t)2760,
  	(opcode_handler_t)2760,
  	(opcode_handler_t)2760,
  	(opcode_handler_t)2760,
  	(opcode_handler_t)2760,
  	(opcode_handler_t)2765,
  	(opcode_handler_t)2765,
  	(opcode_handler_t)2765,
  	(opcode_handler_t)2765,
  	(opcode_handler_t)2765,
  	(opcode_handler_t)2770,
  	(opcode_handler_t)2770,
  	(opcode_handler_t)2770,
  	(opcode_handler_t)2770,
  	(opcode_handler_t)2770,
  	(opcode_handler_t)2775,
  	(opcode_handler_t)2775,
  	(opcode_handler_t)2775,
  	(opcode_handler_t)2775,
  	(opcode_handler_t)2775,
  	(opcode_handler_t)2780,
  	(opcode_handler_t)2780,
  	(opcode_handler_t)2780,
  	(opcode_handler_t)2780,
  	(opcode_handler_t)2780,
  	(opcode_handler_t)2785,
  	(opcode_handler_t)2785,
  	(opcode_handler_t)2785,
  	(opcode_handler_t)2785,
  	(opcode_handler_t)2785,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2795,
  	(opcode_handler_t)2795,
  	(opcode_handler_t)2795,
  	(opcode_handler_t)2795,
  	(opcode_handler_t)2795,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2805,
  	(opcode_handler_t)2806,
  	(opcode_handler_t)2807,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2809,
  	(opcode_handler_t)2810,
  	(opcode_handler_t)2811,
  	(opcode_handler_t)2812,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2814,
  	(opcode_handler_t)2815,
  	(opcode_handler_t)2816,
  	(opcode_handler_t)2817,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2819,
  	(opcode_handler_t)2820,
  	(opcode_handler_t)2821,
  	(opcode_handler_t)2822,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2824,
  	(opcode_handler_t)2825,
  	(opcode_handler_t)2826,
  	(opcode_handler_t)2827,
  	(opcode_handler_t)2828,
  	(opcode_handler_t)2829,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2835,
  	(opcode_handler_t)2836,
  	(opcode_handler_t)2837,
  	(opcode_handler_t)2838,
  	(opcode_handler_t)2839,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2850,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2852,
  	(opcode_handler_t)2853,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2855,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2857,
  	(opcode_handler_t)2858,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2860,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2862,
  	(opcode_handler_t)2863,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2870,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2872,
  	(opcode_handler_t)2873,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2885,
  	(opcode_handler_t)2886,
  	(opcode_handler_t)2887,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2889,
  	(opcode_handler_t)2890,
  	(opcode_handler_t)2891,
  	(opcode_handler_t)2892,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2894,
  	(opcode_handler_t)2895,
  	(opcode_handler_t)2896,
  	(opcode_handler_t)2897,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)2899,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3310,
  	(opcode_handler_t)3311,
  	(opcode_handler_t)3312,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3314,
  	(opcode_handler_t)3315,
  	(opcode_handler_t)3316,
  	(opcode_handler_t)3317,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3319,
  	(opcode_handler_t)3320,
  	(opcode_handler_t)3321,
  	(opcode_handler_t)3322,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3324,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3335,
  	(opcode_handler_t)3336,
  	(opcode_handler_t)3337,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3339,
  	(opcode_handler_t)3340,
  	(opcode_handler_t)3341,
  	(opcode_handler_t)3342,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3344,
  	(opcode_handler_t)3345,
  	(opcode_handler_t)3346,
  	(opcode_handler_t)3347,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3349,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3360,
  	(opcode_handler_t)3361,
  	(opcode_handler_t)3362,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3364,
  	(opcode_handler_t)3365,
  	(opcode_handler_t)3366,
  	(opcode_handler_t)3367,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3369,
  	(opcode_handler_t)3370,
  	(opcode_handler_t)3371,
  	(opcode_handler_t)3372,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3374,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3385,
  	(opcode_handler_t)3386,
  	(opcode_handler_t)3387,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3389,
  	(opcode_handler_t)3390,
  	(opcode_handler_t)3391,
  	(opcode_handler_t)3392,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3394,
  	(opcode_handler_t)3395,
  	(opcode_handler_t)3396,
  	(opcode_handler_t)3397,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3399,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3410,
  	(opcode_handler_t)3411,
  	(opcode_handler_t)3412,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3414,
  	(opcode_handler_t)3415,
  	(opcode_handler_t)3416,
  	(opcode_handler_t)3417,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3419,
  	(opcode_handler_t)3420,
  	(opcode_handler_t)3421,
  	(opcode_handler_t)3422,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3424,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3455,
  	(opcode_handler_t)3455,
  	(opcode_handler_t)3455,
  	(opcode_handler_t)3455,
  	(opcode_handler_t)3455,
  	(opcode_handler_t)3460,
  	(opcode_handler_t)3460,
  	(opcode_handler_t)3460,
  	(opcode_handler_t)3460,
  	(opcode_handler_t)3460,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3470,
  	(opcode_handler_t)3470,
  	(opcode_handler_t)3470,
  	(opcode_handler_t)3470,
  	(opcode_handler_t)3470,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3475,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3500,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3525,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3550,
  	(opcode_handler_t)3575,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3600,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3625,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)3650,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3685,
  	(opcode_handler_t)3686,
  	(opcode_handler_t)3687,
  	(opcode_handler_t)3688,
  	(opcode_handler_t)3689,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3695,
  	(opcode_handler_t)3696,
  	(opcode_handler_t)3697,
  	(opcode_handler_t)3698,
  	(opcode_handler_t)3699,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3710,
  	(opcode_handler_t)3711,
  	(opcode_handler_t)3712,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3714,
  	(opcode_handler_t)3715,
  	(opcode_handler_t)3716,
  	(opcode_handler_t)3717,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3719,
  	(opcode_handler_t)3720,
  	(opcode_handler_t)3721,
  	(opcode_handler_t)3722,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3724,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3725,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)3750,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3800,
  	(opcode_handler_t)3800,
  	(opcode_handler_t)3800,
  	(opcode_handler_t)3800,
  	(opcode_handler_t)3800,
  	(opcode_handler_t)3805,
  	(opcode_handler_t)3805,
  	(opcode_handler_t)3805,
  	(opcode_handler_t)3805,
  	(opcode_handler_t)3805,
  	(opcode_handler_t)3810,
  	(opcode_handler_t)3810,
  	(opcode_handler_t)3810,
  	(opcode_handler_t)3810,
  	(opcode_handler_t)3810,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3820,
  	(opcode_handler_t)3820,
  	(opcode_handler_t)3820,
  	(opcode_handler_t)3820,
  	(opcode_handler_t)3820,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3828,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3850,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)3875,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3913,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3925,
  	(opcode_handler_t)3925,
  	(opcode_handler_t)3925,
  	(opcode_handler_t)3925,
  	(opcode_handler_t)3925,
  	(opcode_handler_t)3930,
  	(opcode_handler_t)3930,
  	(opcode_handler_t)3930,
  	(opcode_handler_t)3930,
  	(opcode_handler_t)3930,
  	(opcode_handler_t)3935,
  	(opcode_handler_t)3935,
  	(opcode_handler_t)3935,
  	(opcode_handler_t)3935,
  	(opcode_handler_t)3935,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3945,
  	(opcode_handler_t)3945,
  	(opcode_handler_t)3945,
  	(opcode_handler_t)3945,
  	(opcode_handler_t)3945,
  	(opcode_handler_t)3950,
  	(opcode_handler_t)3950,
  	(opcode_handler_t)3950,
  	(opcode_handler_t)3950,
  	(opcode_handler_t)3950,
  	(opcode_handler_t)3955,
  	(opcode_handler_t)3955,
  	(opcode_handler_t)3955,
  	(opcode_handler_t)3955,
  	(opcode_handler_t)3955,
  	(opcode_handler_t)3960,
  	(opcode_handler_t)3960,
  	(opcode_handler_t)3960,
  	(opcode_handler_t)3960,
  	(opcode_handler_t)3960,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)-1,
  	(opcode_handler_t)3970,
  	(opcode_handler_t)3970,
  	(opcode_handler_t)3970,
  	(opcode_handler_t)3970,
  	(opcode_handler_t)3970,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)3975,
  	(opcode_handler_t)4000,
  	(opcode_handler_t)4001,
  	(opcode_handler_t)4002,
  	(opcode_handler_t)4003,
  	(opcode_handler_t)4004,
  	(opcode_handler_t)4005,
  	(opcode_handler_t)4006,
  	(opcode_handler_t)4007,
  	(opcode_handler_t)4008,
  	(opcode_handler_t)4009,
  	(opcode_handler_t)4010,
  	(opcode_handler_t)4011,
  	(opcode_handler_t)4012,
  	(opcode_handler_t)4013,
  	(opcode_handler_t)4014,
  	(opcode_handler_t)4015,
  	(opcode_handler_t)4016,
  	(opcode_handler_t)4017,
  	(opcode_handler_t)4018,
  	(opcode_handler_t)4019,
  	(opcode_handler_t)4020,
  	(opcode_handler_t)4021,
  	(opcode_handler_t)4022,
  	(opcode_handler_t)4023,
  	(opcode_handler_t)4024,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4025,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4050,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)4075,
  	(opcode_handler_t)-1
  };
  zend_opcode_handlers = (opcode_handler_t*)labels;
}
static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op)
{
		static const int zend_vm_decode[] = {
			_UNUSED_CODE, /* 0              */
			_CONST_CODE,  /* 1 = IS_CONST   */
			_TMP_CODE,    /* 2 = IS_TMP_VAR */
			_UNUSED_CODE, /* 3              */
			_VAR_CODE,    /* 4 = IS_VAR     */
			_UNUSED_CODE, /* 5              */
			_UNUSED_CODE, /* 6              */
			_UNUSED_CODE, /* 7              */
			_UNUSED_CODE, /* 8 = IS_UNUSED  */
			_UNUSED_CODE, /* 9              */
			_UNUSED_CODE, /* 10             */
			_UNUSED_CODE, /* 11             */
			_UNUSED_CODE, /* 12             */
			_UNUSED_CODE, /* 13             */
			_UNUSED_CODE, /* 14             */
			_UNUSED_CODE, /* 15             */
			_CV_CODE      /* 16 = IS_CV     */
		};
		return zend_opcode_handlers[opcode * 25 + zend_vm_decode[op->op1_type] * 5 + zend_vm_decode[op->op2_type]];
}

ZEND_API void zend_vm_set_opcode_handler(zend_op* op)
{
	op->handler = zend_vm_get_opcode_handler(zend_user_opcodes[op->opcode], op);
}

#undef OPLINE
#undef DCL_OPLINE
#undef USE_OPLINE
#undef LOAD_OPLINE
#undef SAVE_OPLINE
#define OPLINE EX(opline)
#define DCL_OPLINE
#define USE_OPLINE zend_op *opline = EX(opline);
#define LOAD_OPLINE()
#define SAVE_OPLINE()
#undef CHECK_EXCEPTION
#undef HANDLE_EXCEPTION
#undef HANDLE_EXCEPTION_LEAVE
#define CHECK_EXCEPTION() LOAD_OPLINE()
#define HANDLE_EXCEPTION() LOAD_OPLINE(); ZEND_VM_CONTINUE()
#define HANDLE_EXCEPTION_LEAVE() LOAD_OPLINE(); ZEND_VM_LEAVE()
#undef ZEND_VM_CONTINUE
#undef ZEND_VM_RETURN
#undef ZEND_VM_ENTER
#undef ZEND_VM_LEAVE
#undef ZEND_VM_DISPATCH
#undef ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_INTERNAL

#define ZEND_VM_CONTINUE()   return 0
#define ZEND_VM_RETURN()     return 1
#define ZEND_VM_ENTER()      return 2
#define ZEND_VM_LEAVE()      return 3
#define ZEND_VM_DISPATCH(opcode, opline) return zend_vm_get_opcode_handler(opcode, opline)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);

#define ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_INTERNAL execute_data TSRMLS_CC

ZEND_API int zend_do_fcall(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_bool should_change_scope = 0;
	zend_function *fbc = EX(function_state).function;

	SAVE_OPLINE();
	EX(object) = EX(call)->object;
	if (UNEXPECTED((fbc->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_DEPRECATED)) != 0)) {
		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_ABSTRACT) != 0)) {
			zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", fbc->common.scope->name, fbc->common.function_name);
		}
		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_error(E_DEPRECATED, "Function %s%s%s() is deprecated",
				fbc->common.scope ? fbc->common.scope->name : "",
				fbc->common.scope ? "::" : "",
				fbc->common.function_name);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
	}
	if (fbc->common.scope &&
		!(fbc->common.fn_flags & ZEND_ACC_STATIC) &&
		!EX(object)) {

		if (fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
			/* FIXME: output identifiers properly */
			zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically", fbc->common.scope->name, fbc->common.function_name);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		} else {
			/* FIXME: output identifiers properly */
			/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
			zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically", fbc->common.scope->name, fbc->common.function_name);
		}
	}

	if (fbc->type == ZEND_USER_FUNCTION || fbc->common.scope) {
		should_change_scope = 1;
		EX(current_this) = EG(This);
		EX(current_scope) = EG(scope);
		EX(current_called_scope) = EG(called_scope);
		EG(This) = EX(object);
		EG(scope) = (fbc->type == ZEND_USER_FUNCTION || !EX(object)) ? fbc->common.scope : NULL;
		EG(called_scope) = EX(call)->called_scope;
	}

	EX(function_state).arguments = zend_vm_stack_top(TSRMLS_C);
	zend_vm_stack_push((void*)(zend_uintptr_t)opline->extended_value TSRMLS_CC);
	LOAD_OPLINE();

	if (fbc->type == ZEND_INTERNAL_FUNCTION) {
		temp_variable *ret = &EX_T(opline->result.var);

		MAKE_STD_ZVAL(ret->var.ptr);
		ZVAL_NULL(ret->var.ptr);
		ret->var.ptr_ptr = &ret->var.ptr;
		ret->var.fcall_returned_reference = (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) != 0;

		if (fbc->common.arg_info) {
			zend_uint i=0;
			zval **p = (zval**)EX(function_state).arguments;
			ulong arg_count = opline->extended_value;

			while (arg_count>0) {
				zend_verify_arg_type(fbc, ++i, *(p-arg_count), 0 TSRMLS_CC);
				arg_count--;
			}
		}

		if (!zend_execute_internal) {
			/* saves one function call if zend_execute_internal is not used */
			fbc->internal_function.handler(opline->extended_value, ret->var.ptr, (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) ? &ret->var.ptr : NULL, EX(object), RETURN_VALUE_USED(opline) TSRMLS_CC);
		} else {
			zend_execute_internal(execute_data, NULL, RETURN_VALUE_USED(opline) TSRMLS_CC);
		}

		if (!RETURN_VALUE_USED(opline)) {
			zval_ptr_dtor(&ret->var.ptr);
		}
	} else if (fbc->type == ZEND_USER_FUNCTION) {
		EX(original_return_value) = EG(return_value_ptr_ptr);
		EG(active_symbol_table) = NULL;
		EG(active_op_array) = &fbc->op_array;
		EG(return_value_ptr_ptr) = NULL;
		if (RETURN_VALUE_USED(opline)) {
			temp_variable *ret = &EX_T(opline->result.var);

			ret->var.ptr = NULL;
			EG(return_value_ptr_ptr) = &ret->var.ptr;
			ret->var.ptr_ptr = &ret->var.ptr;
			ret->var.fcall_returned_reference = (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) != 0;
		}

		if (UNEXPECTED((EG(active_op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
			if (RETURN_VALUE_USED(opline)) {
				EX_T(opline->result.var).var.ptr = zend_generator_create_zval(EG(active_op_array) TSRMLS_CC);
			}
		} else if (EXPECTED(zend_execute_ex == execute_ex)) {
			if (EXPECTED(EG(exception) == NULL)) {
				ZEND_VM_ENTER();
			}
		} else {
			zend_execute(EG(active_op_array) TSRMLS_CC);
		}

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(return_value_ptr_ptr) = EX(original_return_value);
		if (EG(active_symbol_table)) {
			zend_clean_and_cache_symbol_table(EG(active_symbol_table) TSRMLS_CC);
		}
		EG(active_symbol_table) = EX(symbol_table);
	} else { /* ZEND_OVERLOADED_FUNCTION */
		MAKE_STD_ZVAL(EX_T(opline->result.var).var.ptr);
		ZVAL_NULL(EX_T(opline->result.var).var.ptr);

		/* Not sure what should be done here if it's a static method */
		if (EXPECTED(EX(object) != NULL)) {
			Z_OBJ_HT_P(EX(object))->call_method(fbc->common.function_name, opline->extended_value, EX_T(opline->result.var).var.ptr, &EX_T(opline->result.var).var.ptr, EX(object), RETURN_VALUE_USED(opline) TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot call overloaded function for non-object");
		}

		if (fbc->type == ZEND_OVERLOADED_FUNCTION_TEMPORARY) {
			efree((char*)fbc->common.function_name);
		}
		efree(fbc);

		if (!RETURN_VALUE_USED(opline)) {
			zval_ptr_dtor(&EX_T(opline->result.var).var.ptr);
		} else {
			Z_UNSET_ISREF_P(EX_T(opline->result.var).var.ptr);
			Z_SET_REFCOUNT_P(EX_T(opline->result.var).var.ptr, 1);
			EX_T(opline->result.var).var.fcall_returned_reference = 0;
			EX_T(opline->result.var).var.ptr_ptr = &EX_T(opline->result.var).var.ptr;
		}
	}

	EX(function_state).function = (zend_function *) EX(op_array);
	EX(function_state).arguments = NULL;

	if (should_change_scope) {
		if (EG(This)) {
			if (UNEXPECTED(EG(exception) != NULL) && EX(call)->is_ctor_call) {
				if (EX(call)->is_ctor_result_used) {
					Z_DELREF_P(EG(This));
				}
				if (Z_REFCOUNT_P(EG(This)) == 1) {
					zend_object_store_ctor_failed(EG(This) TSRMLS_CC);
				}
			}
			zval_ptr_dtor(&EG(This));
		}
		EG(This) = EX(current_this);
		EG(scope) = EX(current_scope);
		EG(called_scope) = EX(current_called_scope);
	}

	EX(call)--;

	zend_vm_stack_clear_multiple(1 TSRMLS_CC);

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_throw_exception_internal(NULL TSRMLS_CC);
		if (RETURN_VALUE_USED(opline) && EX_T(opline->result.var).var.ptr) {
			zval_ptr_dtor(&EX_T(opline->result.var).var.ptr);
		}
		HANDLE_EXCEPTION();
	}

	ZEND_VM_NEXT_OPCODE();
}

